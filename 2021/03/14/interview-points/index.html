<!DOCTYPE html>
<html>
<meta  lang="zh-CN" >
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#fff" id="theme-color">
  <link rel="icon" href="/img/logo.png">
  <title>Kibou's blog</title>
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
    var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
      }
    };
    setDarkmode();
  </script>
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
  </script>
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_vpj3dq9ceqa.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  
  <link rel="preload" href="//cdn.jsdelivr.net/npm/fslightbox@3.1.0/index.min.js" as="script">
  
  
  <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  
  <link rel="prefetch" href="//cdn-city.livere.com/js/embed.dist.js" as="script">
  
  
  
  
<link rel="stylesheet" href="/css/main.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_vpj3dq9ceqa.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">

  
  
  
  
  
  <link href="/js/lib/prism/prism-tomorrow.min.css" rel="stylesheet" data-prism="prism-tomorrow">
  
  
  
<link rel="stylesheet" href="/js/lib/prism/prism-line-numbers.min.css">

  
  
  
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <div class="wrapper">
    
    <nav class="navbar">
  <div class="navbar-logo">
    <span class="navbar-logo-main">
      
      <img class="navbar-logo-img" src="/img/logo.png">
      
      <span class="navbar-logo-dsc">Kibou's blog</span>
    </span>
  </div>
  <div class="navbar-menu">
    
    <a href="/" class="navbar-menu-item">首页 </a>
    
    <a href="/archives" class="navbar-menu-item">归档 </a>
    
    <a href="/tags" class="navbar-menu-item">标签 </a>
    
    <a href="/categories" class="navbar-menu-item">分类 </a>
    
    <a href="/about" class="navbar-menu-item">关于 </a>
    
    <a href="/links" class="navbar-menu-item">友链 </a>
    
    <a class="navbar-menu-item darknavbar" id="dark"><i class="iconfont icon-weather"></i></a>
  </div>
</nav>
    
    <div class="section-wrap">
      <div class="container">
        <div class="columns">
          <main class="main-column">
<article class="card card-content">
  <header>
    <h1 class="post-title">
      Java/后端方向 面试常见知识点整理（未完成）
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2021-03-13T16:09:42.000Z" style="display: flex; align-items: center;">
      <i class="iconfont icon-calendar" style="margin-right: 2px;"></i>
      <span>2021-03-14</span>
    </time>
    
    <span class="dot"></span>
    
    <a href="/categories/面试经验/" class="post-meta-link">面试经验</a>
    
    
    
    <span class="dot"></span>
    <span>17.1k 字</span>
    
  </div>
  
  <div class="post-meta post-show-meta" style="margin-top: -10px;">
    <div style="display: flex; align-items: center;">
      <i class="iconfont icon-biaoqian" style="margin-right: 2px; font-size: 1.15rem;"></i>
      
      
        <a href="/tags/Java/" class="post-meta-link">Java</a>
      
      
      <span class="dot"></span>
      
        <a href="/tags/编程思想/" class="post-meta-link">编程思想</a>
      
      
      <span class="dot"></span>
      
        <a href="/tags/Linux/" class="post-meta-link">Linux</a>
      
      
      <span class="dot"></span>
      
        <a href="/tags/MySQL/" class="post-meta-link">MySQL</a>
      
      
      <span class="dot"></span>
      
        <a href="/tags/Redis/" class="post-meta-link">Redis</a>
      
    </div>
  </div>
  
  </header>
  <div id="section" class="post-content">
    <blockquote>
<p>前言：</p>
<p>由个人整理而得，内容来自于参考书籍+各大网络博客+牛客面经等并加上一些个人的简化与理解，仅作为个人知识收集与学习用，如果涉及知识权问题会及时删除（联系email: <a href="mailto:&#122;&#104;&#x61;&#110;&#103;&#107;&#105;&#x62;&#111;&#117;&#x32;&#56;&#51;&#x40;&#x66;&#x6f;&#120;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;">&#122;&#104;&#x61;&#110;&#103;&#107;&#105;&#x62;&#111;&#117;&#x32;&#56;&#51;&#x40;&#x66;&#x6f;&#120;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;</a>）</p>
<p>对于有参考的内容，尽可能地在理解后使用个人语言进行了简化，以知识点的理解为主，缺乏准确性</p>
<p>推荐活用右侧【目录大纲】功能方便快速查阅（移动版的位置在悬浮按钮上）</p>
<p>👇参考了这些大牛的个人博客和内容：</p>
<p><a target="_blank" rel="noopener" href="https://crossoverjie.top/JCSprout">https://crossoverjie.top/JCSprout</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/yuanguangxin/LeetCode/blob/master/Rocket.md">https://github.com/yuanguangxin/LeetCode/blob/master/Rocket.md</a></p>
<p>👇参考较多的一些书籍：</p>
<p>《深入理解 Java 虚拟机 ——JVM 高级特性与最佳实践》</p>
<p>《MySQL 技术内幕 ——InnoDB存储引擎》</p>
<p>《Redis 设计与实现》</p>
</blockquote>
<p><del>来背点八股文</del></p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="与进程的区别"><a href="#与进程的区别" class="headerlink" title="与进程的区别"></a>与进程的区别</h4><ul>
<li><strong>调度粒度：</strong>进程是OS资源分配的最小单位，线程是 CPU 任务调度的最小单位</li>
<li><strong>数据共享：</strong>不同进程之间数据难以共享，同一进程下不同线程数据容易共享</li>
<li><strong>创建开销：</strong>创建和切换线程的消耗更小（切换只需要保存和设置少量寄存器）</li>
<li><strong>资源分配：</strong>系统不会额外为线程再分配内存</li>
<li><strong>依存关系：</strong>一个线程挂掉且不正确捕捉错误会导致整个线程挂掉</li>
</ul>
<h4 id="线程安全的定义"><a href="#线程安全的定义" class="headerlink" title="线程安全的定义"></a>线程安全的定义</h4><p><strong>不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，使用这个资源的行为都可以获得正确的结果</strong>，则线程安全</p>
<h4 id="线程同步措施"><a href="#线程同步措施" class="headerlink" title="线程同步措施"></a>线程同步措施</h4><ul>
<li>非语言的通用措施：互斥对象，临界区，信号量，事件</li>
<li>Java的实现：互斥对象（ReenTrantLock，synchronized对象），临界区（synchronized块），事件（wait,notify,join），信号量（阻塞队列）</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="线程通讯"><a href="#线程通讯" class="headerlink" title="线程通讯"></a>线程通讯</h4><p>较多数据：</p>
<ul>
<li><strong>共享存储</strong>：开辟一块内存空间，将这个空间映射到进程虚拟地址上。速度快和承载量较大但是需要额外同步措施，并且只能单机间操作</li>
<li><strong>消息队列</strong>：点对点或者以信箱为媒介，通过消息队列的方式读取数据，支持随机查询并且适用性高，独立进程存在，缺点是速度较慢</li>
<li><strong>管道通讯</strong>：分为有名和无名两种。单向通讯，通过FIFO的信息流缓冲进行通讯。速度比消息队列更快，缺点是无法随机读写</li>
</ul>
<p>少量数据：信号量</p>
<h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><ul>
<li>按提交顺序，按作业时间，按优先级</li>
<li>按响应比（等待时间/作业时间）</li>
<li>时间片、多级反馈（综合时间片和优先级附带年龄机制）</li>
<li>Linux：动态优先级，不同优先级获得不同时间片，抢占，就绪态队列通过红黑树维护。达到的效果基本上就是高优先级获得较多运行时间，低优先级获得较低时间，同时权重可以动态变化使各个线程调度，并且支持抢占</li>
</ul>
<h3 id="1-死锁四个必要条件"><a href="#1-死锁四个必要条件" class="headerlink" title="1. 死锁四个必要条件"></a>1. 死锁四个必要条件</h3><p>互斥条件：资源独占排他</p>
<p>不可剥夺条件：其他进程无权剥夺进程获得的资源</p>
<p>请求和保持条件：进程在申请它所需的一部分资源的时候，继续占用已分配的资源</p>
<p>循环等待条件：存在等待环路</p>
<h3 id="2-synchronized-关键字原理"><a href="#2-synchronized-关键字原理" class="headerlink" title="2. synchronized 关键字原理"></a>2. synchronized 关键字原理</h3><p>和锁类不同，synchronized 是 JVM 层级的指令。</p>
<p><strong>目标：</strong></p>
<p>synchronized 普通方法：锁住当前对象</p>
<p>synchronized 静态方法：锁住当前 Class 对象</p>
<p>synchronized 块：锁住 （）中的对象</p>
<p>JVM 通过进入，退出对象监视器（Monitor）来实现对方法、同步块的同步。类似于获取互斥量，如果获取不到则会阻塞在方法入口处，等待其他线程 exit 后才能继续尝试获取锁</p>
<p>在 JDK 1.6 之前称为重量锁，之后引入了 偏向锁 和 轻量锁</p>
<h4 id="轻量锁"><a href="#轻量锁" class="headerlink" title="轻量锁"></a>轻量锁</h4><p>当代码进入同步块时，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(<code>Lock Record</code>)区域，同时将锁对象的对象头中 <code>Mark Word</code> 拷贝到锁记录中，再尝试使用 <code>CAS</code> 将 <code>Mark Word</code> 更新为指向锁记录的指针。</p>
<p>如果更新成功，当前线程就获得了锁。</p>
<p>如果更新失败 <code>JVM</code> 会先检查锁对象的 <code>Mark Word</code> 是否指向当前线程的锁记录。</p>
<p>如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。</p>
<p>不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，<strong>轻量锁就会膨胀为重量锁</strong>。</p>
<p>解锁时也利用 CAS ，尝试用锁记录替换回对象的 MW ，如果不成功说明有其他线程在尝试获取锁，那么就唤醒挂起的线程。（此时已经是重量锁）</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>特征是一个线程在没有损耗的情况下多次获得该锁</p>
<p>当线程访问同步块时，会使用 CAS 将线程 ID 更新到锁对象的 MW 中，如果更新成功则获得偏向锁，并且之后每次进入这个对象锁相关的同步块时都不需要再次获取锁了。</p>
<p>释放锁的时机：当有另外一个线程获取这个锁时，持有偏向锁的线程就会释放锁，释放时会等待全局安全点(这一时刻没有字节码运行)，接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁来判定将对象头中的 <code>Mark Word</code> 设置为无锁或者是轻量锁状态。</p>
<p>可以提高竞争少的同步程序性能</p>
<h3 id="3-volatile-作用"><a href="#3-volatile-作用" class="headerlink" title="3. volatile 作用"></a>3. volatile 作用</h3><p>用于保证可见性和顺序性。</p>
<p>可见性：volatile 修饰的变量被更新时，将立刻刷新到主线程，同时将缓存内该变量其他值清空，导致其余线程仅能去内存中读取值</p>
<p>顺序性：volatile 可以保证对修饰对象的操作顺序性，不会被JVM重排，防止多线程时出现可能的问题</p>
<h3 id="4-ReentrantLock-实现原理"><a href="#4-ReentrantLock-实现原理" class="headerlink" title="4. ReentrantLock 实现原理"></a>4. ReentrantLock 实现原理</h3><p>一个 <strong>重入锁</strong> 类，基于 AQS(AbstractQueuedSynchronizer) 实现</p>
<p>有<strong>公平锁</strong>和<strong>非公平锁</strong>两种，默认为非公平锁</p>
<p>通常的使用结构：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">//do bussiness</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>基本过程（简略版的）：</p>
<ol>
<li>根据 state 判断该锁是否未占用，如果未占用，用 CAS 尝试修改状态</li>
<li>如果获取锁失败，进入队列（通过自旋和CAS保证一定进入队列），然后将自身线程挂起</li>
<li>在队列中时，如果被唤醒后尝试获取锁</li>
<li>由于是重入锁，释放时会保证 state 减到 0 才认为锁被完全释放了</li>
</ol>
<p>公平锁和非公平锁在 1. 和 3. </p>
<p>非公平锁（<strong>抢占</strong>）：在 1. 步不管队列情况，直接尝试获取锁。在 3. 步也是只要唤醒就尝试获取锁</p>
<p>公平锁（<strong>排队</strong>）：在 1. 步检查队列情况，如果队列有人则不会尝试获取锁（排队）。在 3. 步唤醒后，先检查自己队列前面是否还有人，如果有则不尝试获取，直接阻塞</p>
<p>公平锁的队列顺序获取锁会造成大量的线程上下文切换。</p>
<h3 id="5-HashMap-实现"><a href="#5-HashMap-实现" class="headerlink" title="5. HashMap 实现"></a>5. HashMap 实现</h3><p><strong>基本要素：</strong></p>
<p>数组+链表/红黑树。<strong>容量</strong>（默认16），<strong>负载因子</strong>（0.75），<strong>扩容倍数</strong>：2（原因：保持map的2^n大小；减少元素移动）</p>
<p>put方法：</p>
<p>将传入的 Key 哈希后再对数组长度位运算，计算数组中的 index 下标</p>
<p>位运算比取模效率高得多，所以 HashMap 规定数组长度 2^n ，这样和取模结果一致。</p>
<p>如果出现 Hash 碰撞，那么会在该位置头插法插入链表</p>
<p>get方法：</p>
<p>传入 key 计算 index，如果位置上是链表则遍历，通过 equals 得出对应元素</p>
<h4 id="JDK1-8-变动"><a href="#JDK1-8-变动" class="headerlink" title="JDK1.8 变动"></a>JDK1.8 变动</h4><p>从头插改为了尾插，避免死链（但是本身它仍然是一个非线程安全的容器）</p>
<p>当 hash碰撞之后写入链表的长度超过了阈值(默认为8)并且 table 的长度不小于64(否则扩容一次)时，链表将会转换为<strong>红黑树</strong>。</p>
<h4 id="哈希冲突措施"><a href="#哈希冲突措施" class="headerlink" title="哈希冲突措施"></a>哈希冲突措施</h4><ul>
<li>开放定址：即根据本次哈希结果p1基础再按某种规则生成下一个新的哈希结果p2，然后重复<ul>
<li>线性探测：放到下一个单位</li>
<li>伪随机：随机数</li>
</ul>
</li>
<li>再哈希：构建一个备用哈希函数（HSn）专门给第n次hash使用，特点是每次哈希的计算方式不同</li>
<li>链地址：使用较多的方法，将所有哈希位置更改为链表或其他存储结构，然后将重复的元素组织在同一位置</li>
<li>溢出表：另外专门分开一个溢出表部分</li>
</ul>
<h3 id="6-ConcurrentHashMap-实现"><a href="#6-ConcurrentHashMap-实现" class="headerlink" title="6. ConcurrentHashMap 实现"></a>6. ConcurrentHashMap 实现</h3><h4 id="JDK1-7实现："><a href="#JDK1-7实现：" class="headerlink" title="JDK1.7实现："></a>JDK1.7实现：</h4><p>结构：</p>
<p><strong>Segment</strong> 数组，HashEntry 数组，与 HashMap 一样的【数组加链表设计】</p>
<p>ConcurrentHashMap 采用分段锁，Segment部分是继承于 【ReentrantLock】，这使得Segment不会像 HashTable 一样不管是put 还是 get 都需要同步，理论上CHMap支持Segment数量级别的线程并发，<strong>一个Segment的锁占用不影响其他Segment</strong></p>
<p>get 方法：不需要加锁，只需要hash定位Segment，且再hash定位到具体元素即可（两次Hash）</p>
<p>put 方法：Segment加锁，再更新</p>
<p>size 方法：</p>
<p>缺点：段较多时会【浪费空间】；在竞争同分段概率较小的情境下put操作【加锁浪费时间】；段较大时会使性能下降</p>
<h4 id="JDK1-8实现："><a href="#JDK1-8实现：" class="headerlink" title="JDK1.8实现："></a>JDK1.8实现：</h4><p>取消了 Sagment 以及其分段锁，用<strong>Node数组+链表/红黑树</strong>的数据结构来实现，类似于原本的HashSet，存放数据的 HashEntry 改为 Node ，作用差不多</p>
<p>get 方法：用计算的 hashcode 寻址，如果在 Node 上直接返回，如果没有根据 Node 所指向数据结构的差别寻址（链表或红黑树）</p>
<p>put 方法：val 本身使用 volatile修饰，计算出 hashcode 并定位后，如果可以写入（为空），<strong>先通过 CAS 尝试写入</strong>，失败则会自旋。否则（不为空），<strong>使用 synchronized 锁写入</strong>。</p>
<h3 id="7-线程-线程池"><a href="#7-线程-线程池" class="headerlink" title="7. 线程 / 线程池"></a>7. 线程 / 线程池</h3><h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><p>创建，就绪，运行，阻塞，终结</p>
<h4 id="线程的创建方式与区别"><a href="#线程的创建方式与区别" class="headerlink" title="线程的创建方式与区别"></a>线程的创建方式与区别</h4><p>创建方式：</p>
<ul>
<li>创建一个实现 Runnable 接口的实例，然后将该类实例传给 Thread 类创建 Thread 对象，并start</li>
<li>继承 Thread 类并实现 run() 方法，创建对象并start</li>
<li>通过线程池创建（最终通过 new Thread() 创建）</li>
<li>其他（Callable，Timer）</li>
</ul>
<p>实际上都是通过创建一个 Thread 类来创建，对于 Runnable 接口和 Thread 类来说只是线程内容运行的不同（Runnable 方式可以视为一种函数式接口去定义 Thread 运行内容）</p>
<p>最好是通过实现 Runnable 方式来创建，这样可以将线程本身的设置与运行业务代码分隔开</p>
<h4 id="线程池的参数，种类和使用的好处"><a href="#线程池的参数，种类和使用的好处" class="headerlink" title="线程池的参数，种类和使用的好处"></a>线程池的参数，种类和使用的好处</h4><p>好处：</p>
<ul>
<li>线程可<strong>复用</strong>，减少线程建立与销毁的开销</li>
<li>控制线程<strong>数量</strong>，随情况调整</li>
<li>实现线程的<strong>统一管理</strong>（统一开始与结束，数据统计）</li>
</ul>
<p>参数：</p>
<p>corePoolSize                能够同时工作的最大线程数（再提交任务会放入 workQueue）<br>maxPoolSize                    线程池最大线程数（超过该线程数后会拒绝任务）<br>keepAliveTime+时间            线程数多余 corePoolSize 时，这些线程的保活时间<br>ThreadFactory                线程工厂的种类<br>workQueue                    阻塞队列的种类<br>Handler                        任务拒绝策略</p>
<p>种类：</p>
<p>线程数固定值，Queue容量无限制</p>
<ul>
<li>FixedThreadPool</li>
<li>SingleThreadExecutor</li>
</ul>
<p>Queue容量0，线程数无限制</p>
<ul>
<li>CachedThreadPool</li>
</ul>
<p>加上定时运行（Queue容量仍无限制）</p>
<ul>
<li>ScheduledThreadPool</li>
<li>SingleThreadScheduledExecutor</li>
</ul>
<p>包含子任务</p>
<ul>
<li>ForkJoinPool</li>
</ul>
<p>阿里的开发规范要求我们尽量自行创建提供全参数的 <strong>ThreadPoolExecutor</strong> 而不是 Executors.newPool() 预定义的线程构造方法，避免（Queue和线程数无限制引起的）OOM</p>
<h3 id="8-ThreadLocal-和-Inherittable"><a href="#8-ThreadLocal-和-Inherittable" class="headerlink" title="8. ThreadLocal 和 Inherittable"></a>8. ThreadLocal 和 Inherittable</h3><h4 id="ThreadLocal-的简单大致理解"><a href="#ThreadLocal-的简单大致理解" class="headerlink" title="ThreadLocal 的简单大致理解"></a>ThreadLocal 的简单大致理解</h4><ul>
<li>是什么？</li>
</ul>
<p>一个线程间隔离的共享变量，每个线程存取 Threadlocal 拿到的是自己的私有对象，可以当作私有成员一样使用</p>
<ul>
<li>ThreadLocal 实现副本的机制？</li>
</ul>
<p>ThreadLocal 本身并不存储数值，每个线程的值存放在自己线程的 ThreadLocalMap （一个HashMap）中。每个线程通过访问唯一的共享静态变量 ThreadLocal T ，将其作为键值来访问自己的 Map ，从而提取自己所维护的值（这样做的原因是也是为了支持使用泛型）</p>
<p><img src="https://cdn.jsdelivr.net/gh/syameimarukibou/imagebox/img/H772_~O8TYY$[HO36VDAWM4.hc" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.jsdelivr.net/gh/syameimarukibou/imagebox/img/H772_~O8TYY$[HO36VDAWM4.hc" class="lozad post-image"></p>
<ul>
<li>和 线程局部变量 的区别？为什么不直接用局部变量？</li>
</ul>
<p>都具有隔离性，但是 ThreadLocal 可以在线程内各个方法间共享，相当于<strong>线程的全局变量</strong></p>
<p>相较于局部变量，1. ThreadLocal 具有<strong>线程内全局性</strong>，可以在方法之间直接共享使用，使用更方便而不需要传参。2. ThreadLocal 一定程度上可以控制对象创建的开销，因为副本对象的创建是跟线程走的，如果线程可以得到复用（考虑线程池），那么 ThreadLocal 创建的对象也可以复用</p>
<ul>
<li>内存泄漏？</li>
</ul>
<p>Map 中的 key 为弱引用，在任一次 GC 之后会被回收，使得 key 为null。Map 提供一个 expungeStaleEntry 方法，可以将 null key 的 value 置为空，这个方法一般会在每次访问 ThreadLocal 时（set,remove,rehash 等）都被检查一次。</p>
<p>但是如果 ThreadLocal 本身在这些操作之前就已经不再使用，而线程又不终止，那么 value 仍然不会被回收，导致 value 的内存泄漏。所以尽可能在完全不使用 ThreadLocal 之后显式调用它的 remove 方法。</p>
<ul>
<li>使用案例</li>
</ul>
<p>典型的一个使用场景的案例（同时使用了线程池）：每个线程根据自己所给参数的秒数打印一个格式化时间，实现按格式顺序打印1000秒：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalDemo06</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> threadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>
            threadPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token comment">// 每个线程的 SimpleDateFormat 对象可以被重复利用，构造的SimpleDateFormat 的最大次数仅有16个</span>
                    <span class="token class-name">String</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalDemo06</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">date</span><span class="token punctuation">(</span>finalI<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">date</span><span class="token punctuation">(</span><span class="token keyword">int</span> seconds<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Date</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">*</span> seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">SimpleDateFormat</span> dateFormat <span class="token operator">=</span> <span class="token class-name">ThreadSafeFormatter</span><span class="token punctuation">.</span>dateFormatThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> dateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">ThreadSafeFormatter</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SimpleDateFormat</span><span class="token punctuation">></span></span> dateFormatThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SimpleDateFormat</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token class-name">SimpleDateFormat</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 输出：</span>
<span class="token comment">// 00:00</span>
<span class="token comment">// 00:01</span>
<span class="token comment">// 00:02</span>
<span class="token comment">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="5种IO以及-select-poll-epoll"><a href="#5种IO以及-select-poll-epoll" class="headerlink" title="5种IO以及 select poll epoll"></a>5种IO以及 select poll epoll</h3><h4 id="5种IO"><a href="#5种IO" class="headerlink" title="5种IO"></a>5种IO</h4><ul>
<li><strong>同步阻塞</strong>：用户线程进行IO操作时，直到内核返回结果前阻塞。体现在在java io文件读取和写入</li>
<li><strong>同步非阻塞</strong>：用户线程发出请求后返回，但是无法读到任何数据，需要之后不断发起IO请求轮询</li>
<li><strong>IO多路复用/异步阻塞IO：</strong></li>
</ul>
<p>建立在内核提供的多路分离函数select，poll，epoll之上，目的是避免同步非阻塞IO模型中轮询等待的问题</p>
<p>添加一个 Reactor ,用户线程向 Reactor 注册事件处理器，把轮询IO操作的 select 操作交给Reactor处理，Reactor select 到某个数据准备完成后，通知对应的用户线程（调用用户的回调函数），让用户去进行读取内核准备好的数据</p>
<p>Reactor 可以注册多个用户线程，从而将轮询工作集中起来</p>
<ul>
<li><strong>信号驱动IO</strong></li>
</ul>
<p>用户线程发出请求后返回，但是自己不再主动发起轮询请求，而是内核准备好后，向该线程发送一个信号（调用信号回调函数），线程开始去读数据</p>
<ul>
<li><strong>异步IO</strong></li>
</ul>
<p>用户线程发出请求后返回，内核完成IO之后直接会将数据复制到用户空间，并发送一个完成通知，用户在自己空间内进行对数据的操作，内核就不需要再应对该用户的请求。</p>
<h4 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select poll epoll"></a>select poll epoll</h4><table>
<thead>
<tr>
<th align="center">\</th>
<th align="center">select</th>
<th align="center">poll</th>
<th align="center">epoll</th>
</tr>
</thead>
<tbody><tr>
<td align="center">操作方式</td>
<td align="center">遍历</td>
<td align="center">遍历</td>
<td align="center">回调</td>
</tr>
<tr>
<td align="center">底层实现</td>
<td align="center">数组</td>
<td align="center">链表</td>
<td align="center">哈希表</td>
</tr>
<tr>
<td align="center">IO效率</td>
<td align="center">每次调用都进行线性遍历，时间复杂度为O(n)</td>
<td align="center">每次调用都进行线性遍历，时间复杂度为O(n)</td>
<td align="center">事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到rdllist里面。时间复杂度O(1)</td>
</tr>
<tr>
<td align="center">最大连接数</td>
<td align="center">1024（x86）或 2048（x64）</td>
<td align="center">无上限</td>
<td align="center">无上限</td>
</tr>
<tr>
<td align="center">fd拷贝</td>
<td align="center">每次调用select，都需要把fd集合从用户态拷贝到内核态</td>
<td align="center">每次调用poll，都需要把fd集合从用户态拷贝到内核态</td>
<td align="center">调用epoll_ctl时拷贝进内核并保存，之后每次epoll_wait不拷贝</td>
</tr>
</tbody></table>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="1-运行时内存结构"><a href="#1-运行时内存结构" class="headerlink" title="1. 运行时内存结构"></a>1. 运行时内存结构</h3><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.jsdelivr.net/gh/syameimarukibou/imagebox/img/5d31384c568c531115.jpg" class="lozad post-image"src="https://cdn.jsdelivr.net/gh/syameimarukibou/imagebox/img/5d31384c568c531115.jpg"></p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>与 VM Stack 类似，区别只在VMStack只为虚拟机执行Java方法服务，而 Native Method Stack 则为虚拟机使用到的 <strong>Native 方法</strong>服务。</p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p><strong>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</strong></p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>当前线程所执行的字节码的行号指示器，用于<strong>获取下一条执行的字节码</strong>。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</p>
<h4 id="方法区-元空间（共享）"><a href="#方法区-元空间（共享）" class="headerlink" title="方法区/元空间（共享）"></a>方法区/元空间（共享）</h4><p>（JDK1.7）方法区主要用于存放已经被虚拟机加载的类信息，如<code>常量，静态变量</code>。 这块区域也被称为<code>永久代</code>。</p>
<p>（JDK1.8）该区域被废弃，作为代替引入元空间（MetaSpace），使用<strong>本地内存</strong>而不是虚拟机管理的内存。</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>和元空间同属本地内存，不由 JVM 虚拟机管理</p>
<p>NIO，以及调用 NIO 的 Netty 会使用这些部分</p>
<h4 id="堆（共享）"><a href="#堆（共享）" class="headerlink" title="堆（共享）"></a>堆（共享）</h4><p><strong>Java虚拟机所管理的内存中最大的一块。几乎所有对象实例创建发生在这个区域</strong></p>
<p>可利用参数 <code>-Xms -Xmx</code> 进行堆内存大小控制。同时也是垃圾回收器的重点管理区域。由于大部分垃圾回收器采用 <strong>分代回收算法</strong> 所以堆内存一般也划分成新生代，老年代等，便于方便的回收</p>
<p>将 -Xms -Xmx 设置为同样大小可以减少 JVM 去向操作系统申请内存的次数</p>
<h3 id="2-对象创建与内存分配"><a href="#2-对象创建与内存分配" class="headerlink" title="2. 对象创建与内存分配"></a>2. 对象创建与内存分配</h3><h4 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h4><ol>
<li>编译器通过逃逸分析（判断指标：<strong>一、对象是否被赋值给堆中对象的字段和类的静态变量。二、对象被传进了不确定的代码中去运行</strong>），确定对象是在栈上分配还是在堆上分配。如果是在堆上分配，则进入2.</li>
<li>如果tlab_top + size &lt;= tlab_end，即当前TLAB空间可用，则在在<strong>TLAB</strong>上直接分配对象并增加tlab_top 的值，如果现有的TLAB不足以存放当前对象则3.</li>
<li>重新申请一个TLAB，并再次尝试存放当前对象。如果放不下，则4。</li>
<li>在Eden区加锁（这个区是多线程共享的），如果eden_top + size &lt;= eden_end则将对象存放在Eden区，增加eden_top 的值，如果Eden区不足以存放，则5。</li>
<li>执行一次Young GC（minor collection）</li>
<li>经过Young GC之后，如果Eden区任然不足以存放当前对象，则直接分配到老年代。</li>
</ol>
<p>可以看出优先级顺序为：栈分配 -&gt; TLAB -&gt; Eden -&gt; (YoungGC后)Eden -&gt; 老年代 </p>
<h4 id="关于TLAB"><a href="#关于TLAB" class="headerlink" title="关于TLAB"></a>关于TLAB</h4><p>在Java中，典型的对象不再堆上分配的情况有两种：TLAB和栈上分配（通过逃逸分析）。</p>
<p>TLAB（Thread-local allocation buffer）是：JVM在内存新生代<strong>Eden Space</strong>中开辟的一小块<strong>线程私有</strong>的区域。默认设定为占用Eden Space的1%。</p>
<p>在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且<strong>TLAB上的分配由于是线程私有所以没有锁开销</strong>。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。</p>
<p>也就是说，Java中<strong>每个线程都会有自己的缓冲区称作TLAB（Thread-local allocation buffer）</strong>，每个TLAB都只有一个线程可以操作，TLAB结合bump-the-pointer技术可以实现快速的对象分配，而不需要任何的锁进行同步，也就是说，在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可。</p>
<h4 id="对象内存分配的两种方法"><a href="#对象内存分配的两种方法" class="headerlink" title="对象内存分配的两种方法"></a>对象内存分配的两种方法</h4><ol>
<li><strong>指针碰撞</strong>(Serial、ParNew等带Compact过程的收集器) ：假设Java堆中<strong>内存是绝对规整的</strong>，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就<strong>仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离</strong>，这种分配方式称为“指针碰撞”（Bump the Pointer）。</li>
<li><strong>空闲列表</strong>(CMS这种基于Mark-Sweep算法的收集器) ：如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，<strong>虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例</strong>，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。</li>
</ol>
<h4 id="对象GC后的移动顺序"><a href="#对象GC后的移动顺序" class="headerlink" title="对象GC后的移动顺序"></a>对象GC后的移动顺序</h4><ol>
<li>新创建对象（如果不在栈上分配）分配在 Eden 区，如果较小可以放在线程私有的TLAB区（除非过大，再 Minor GC 之后仍然无法放入）</li>
<li>对象经过第一次 Minor GC 后，如果存活，那么移动到 Survivor 区（每熬过一次 Minor GC，年龄+1，到一定值之后进入老年代）</li>
<li>对于所有 Survivor 区的对象，内存被分为两块，保证同一时间所有对象处于其中一块，Minor GC后，未进入老年的对象统一被复制到另一块对象。</li>
</ol>
<h3 id="3-内存回收"><a href="#3-内存回收" class="headerlink" title="3. 内存回收"></a>3. 内存回收</h3><h4 id="判断对象废弃的方法（垃圾回收机制）"><a href="#判断对象废弃的方法（垃圾回收机制）" class="headerlink" title="判断对象废弃的方法（垃圾回收机制）"></a>判断对象废弃的方法（垃圾回收机制）</h4><p>引用计数：每个对象都含有一个引用计数器,当有引用连接至对象时,引用计数加1，当引用离开作用域或被置为null时,引用计数减1。垃圾回收器会在含有全部对象的列表上遍历,当发现某个对象引用计数为0时,就释放其占用的空间。</p>
<p>可达性分析：这个算法的基本思路就是通过一系列的称为“<strong>GC Roots</strong>”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连，那么该对象不可用</p>
<h4 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h4><p>如之前所述，HotSpot JVM中年轻代中使用复制，在年老代使用标记-清除或标记-整理</p>
<h4 id="CMS，G1"><a href="#CMS，G1" class="headerlink" title="CMS，G1"></a>CMS，G1</h4><h5 id="CMS执行过程"><a href="#CMS执行过程" class="headerlink" title="CMS执行过程"></a>CMS执行过程</h5><ul>
<li><strong>初始标记(STW initial mark)**：从垃圾回收的”根对象”开始，只扫描到能够和”根对象”直接关联的对象，并作标记。所以这个过程虽然</strong>暂停了整个JVM**，但是很快就完成了。</li>
<li>**并发标记(Concurrent marking)**：紧随初始标记阶段，并发进行。在初始标记的基础上继续向下追溯标记。所以用户不会感受到停顿。</li>
<li><strong>重新标记(STW remark)**：这个阶段会暂停虚拟机，查找在执行</strong>并发标记阶段**发生的产生了变化的那一部分对象</li>
<li>**并发清理(Concurrent sweeping)**：并发。清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。</li>
<li>**并发重置(Concurrent reset)**：这个阶段，重置CMS收集器的数据结构状态，等待下一次垃圾回收。</li>
</ul>
<h5 id="G1执行过程"><a href="#G1执行过程" class="headerlink" title="G1执行过程"></a>G1执行过程</h5><ul>
<li>**初始标记(STW)**：短暂STW，初始标记，顺带触发一次young GC</li>
<li><strong>并发标记：</strong>并发<strong>。</strong>在整个堆中进行，并且和应用程序并发运行，可能被 young GC 打断如果发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，每个<strong>区域的对象活性</strong>(区域中存活对象的比例)被计算。</li>
<li><strong>再标记</strong>：用来补充收集并发标记阶段产新的新垃圾。与之不同的是，G1中采用了更快的算法:SATB</li>
<li>**清理阶段(STW)**：选择活性低的区域(同时考虑停顿时间)，等待下次young GC一起收集，这个过程也会有停顿(STW)。</li>
<li><strong>回收/完成</strong>：新的young GC清理被计算好的区域。但是有一些区域还是可能存在垃圾对象，可能是这些区域中对象活性较高，回收不划算，也肯能是为了迎合用户设置的时间，不得不舍弃一些区域的收集。</li>
</ul>
<h5 id="G1与CMS的比较"><a href="#G1与CMS的比较" class="headerlink" title="G1与CMS的比较"></a>G1与CMS的比较</h5><ul>
<li>CMS收集器是<strong>获取最短回收停顿时间</strong>为目标的收集器，因为CMS工作时，GC工作线程与用户线程可以并发执行，以此来达到降低停顿时间的目的（只有初始标记和重新标记会STW）。但是CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降。</li>
<li>CMS仅作用于<strong>老年代</strong>，是基于【标记清除算法】，所以清理的过程中会有大量的<strong>空间碎片</strong>。</li>
<li>CMS收集器<strong>无法处理浮动垃圾</strong>，由于CMS并发清理阶段用户线程还在运行，伴随程序的运行自热会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只好留待下一次GC时将其清理掉。</li>
<li>G1是一款面向服务端应用的垃圾收集器，<strong>适用于多核处理器、大内存容量的服务端系统</strong>。G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短STW的停顿时间，它满足<strong>短时间停顿的同时达到一个高的吞吐量</strong>。</li>
<li>从JDK 9开始，G1成为默认的垃圾回收器。当应用有以下任何一种特性时非常适合用G1：**Full GC持续时间太长或者太频繁；对象的创建速率和存活率变动很大；应用不希望停顿时间长(长于0.5s甚至1s)**。</li>
<li>G1将空间划分成很多<strong>块（Region）</strong>，然后他们各自进行回收。堆比较大的时候可以采用<strong>复制算法</strong>，碎片化问题不严重。<strong>整体上看属于标记整理算法,局部(region之间)属于复制算法</strong>。</li>
<li>G1 <strong>需要记忆集来记录新生代和老年代之间的引用关系，这种数据结构在 G1 中需要占用大量的内存</strong>，可能达到整个堆内存容量的 20% 甚至更多。而且 G1 中维护记忆集的成本较高，带来了更高的执行负载，影响效率。所以 <strong>CMS 在小内存应用上的表现要优于 G1，而大内存应用上 G1 更有优势</strong>，大小内存的界限是6GB到8GB。（Card Table（CMS中）的结构是一个连续的byte[]数组，扫描Card Table的时间比扫描整个老年代的代价要小很多！G1也参照了这个思路，不过采用了一种新的数据结构 Remembered Set 简称Rset。RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。而Card Table则是一种points-out（我引用了谁的对象）的结构，每个Card 覆盖一定范围的Heap（一般为512Bytes）。G1的RSet是在Card Table的基础上实现的：每个Region会记录下别的Region有指向自己的指针，并标记这些指针分别在哪些Card的范围内。 这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。每个Region都有一个对应的Rset。）</li>
</ul>
<h3 id="4-类加载"><a href="#4-类加载" class="headerlink" title="4. 类加载"></a>4. 类加载</h3><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="1-Linux与查看资源相关的指令"><a href="#1-Linux与查看资源相关的指令" class="headerlink" title="1. Linux与查看资源相关的指令"></a>1. Linux与查看资源相关的指令</h3><h4 id="ps-进程"><a href="#ps-进程" class="headerlink" title="ps 进程"></a>ps 进程</h4><p>静态查看<strong>进程统计信息</strong>（主要包括pid，CPU/MEM 占用百分比，状态，占用CPU时间等）（一般使用 ps -aux 或者 ps -elf）</p>
<p>常用手段：</p>
<p>获取第一个包含“java”信息的进程：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ps -elf |grep java|grep -v grep |head -n 1 |awk &#39;&#123;printf $4&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="top-进程"><a href="#top-进程" class="headerlink" title="top 进程"></a>top 进程</h4><p>动态查看<strong>进程活动状态</strong>，比 ps 多了所有进程的统计总览以及总体资源情况</p>
<h4 id="pgrep-进程"><a href="#pgrep-进程" class="headerlink" title="pgrep 进程"></a>pgrep 进程</h4><p>查询<strong>指定进程信息</strong>，默认输入进程名输出进程Pid</p>
<h4 id="free-内存"><a href="#free-内存" class="headerlink" title="free 内存"></a>free 内存</h4><p>显示<strong>系统内存</strong>情况</p>
<h4 id="proc-meminfo-内存"><a href="#proc-meminfo-内存" class="headerlink" title="/proc/meminfo 内存"></a>/proc/meminfo 内存</h4><p>存储了比 free 更丰富的内存状态的接口</p>
<h4 id="vmstat-基本状态"><a href="#vmstat-基本状态" class="headerlink" title="vmstat 基本状态"></a>vmstat 基本状态</h4><p>显示<strong>动态服务器状态值</strong>（CPU,内存，硬盘IO读写）</p>
<h4 id="lsof-i-网络"><a href="#lsof-i-网络" class="headerlink" title="lsof -i 网络"></a>lsof -i 网络</h4><p>查看<strong>所有连接</strong>。一般用用 losf -i:port 来显示指定端口被占用的信息</p>
<h4 id="netstat-网络"><a href="#netstat-网络" class="headerlink" title="netstat 网络"></a>netstat 网络</h4><p><code>netstat -tunlp</code>：查看所有【 (-t)tcp (-u)udp (-n)不显示别名 (-l)正在listen的 (-p)建立相关链接的程序名】 的<strong>连接</strong>。加上 | grep (port) 可以显示指定端口的情况</p>
<p><code>df -h</code>：查看<strong>磁盘状态</strong></p>
<h3 id="2-如何获取一个网络访问log中-访问记录最多的前10个ip？"><a href="#2-如何获取一个网络访问log中-访问记录最多的前10个ip？" class="headerlink" title="2 如何获取一个网络访问log中 访问记录最多的前10个ip？"></a>2 如何获取一个网络访问log中 访问记录最多的前10个ip？</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cat test.log &#96;# 获取log&#96; \
&gt; | awk -F&quot; &quot; &#39;&#123;print $2&#125;&#39; &#96; #假设Ip地址所在的列数已知为第2列，提取该列&#96; \
&gt; | sort &#96;# 按默认排序&#96; \
&gt; | uniq -c &#96;# 统计唯一项，并标出重复项&#96; \
&gt; | sort -nrk 1 -t&#39; &#39; &#96;# -n: 按照数值大小排序，-r 降序，-k 1 参照指定第1列进行排序&#96; \
&gt; | awk -F&quot; &quot; &#39;&#123;print $2&#125;&#39; &#96;# 打印排序后结果的ip部分&#96;\
&gt; | head -10 &#96;# 显示头10个&#96;\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-Linux-常用文本处理操作-grep-sed-awk"><a href="#3-Linux-常用文本处理操作-grep-sed-awk" class="headerlink" title="3. Linux 常用文本处理操作 grep sed awk"></a>3. Linux 常用文本处理操作 grep sed awk</h3><h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>功能：逐<strong>行</strong>扫描文件，并且对于符合匹配内容的行，在该行上执行用户指定的操作。</p>
<p>操作单位：<strong>行</strong></p>
<p>结构：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">awk [-选项] &#39;[匹配规则]&#123;执行命令&#125;&#39; 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<table>
<thead>
<tr>
<th>选项(options)</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-F fs</td>
<td>指定以 fs 作为行分割符，默认为空格/制表符</td>
</tr>
<tr>
<td>-f file</td>
<td>从脚本文件读取 awk 脚本指令代替直接输入指令</td>
</tr>
<tr>
<td>-v var=val</td>
<td>执行处理过程前，设置一个变量 var 并赋予初始值 val</td>
</tr>
</tbody></table>
<p>最重要的部分在于 <code> &#39;[匹配规则]&#123;执行命令&#125;&#39;</code> 所组成的脚本命令。如果**没有匹配规则则默认匹配所有行。</p>
<p>awk 可以自动给一行中的每个元素分配变量：</p>
<ul>
<li>$0 代表整个文本行；</li>
<li>$1 代表文本行中的第 1 个数据字段；</li>
<li>$2 代表文本行中的第 2 个数据字段；</li>
<li>$n 代表文本行中的第 n 个数据字段。</li>
</ul>
<p>可以执行多个命令，用 ; 隔开即可</p>
<p>使用举例：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">awk -F&quot; &quot; &#39;&#123;print $2&#125;&#39; test.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>获取 test.log 中的数据，按空格为行分割符，并打印第二列内容</p>
<h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>功能：扫描文件内所有内容，找出符合匹配条件的所有行</p>
<p>操作单位：<strong>行</strong></p>
<p>结构：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">grep [选项] 模式 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-c</strong></td>
<td>仅列出文件包含模式的行数</td>
</tr>
<tr>
<td><strong>-i</strong></td>
<td>忽略模式中的字母大小写</td>
</tr>
<tr>
<td>-l</td>
<td>列出带有匹配行的文件名</td>
</tr>
<tr>
<td>-n</td>
<td>在每一行的最前面列出行号</td>
</tr>
<tr>
<td>-v</td>
<td>列出没有匹配模式的行</td>
</tr>
<tr>
<td>-w</td>
<td>把表达式当作一个完整单字符搜索，忽略部分匹配的行</td>
</tr>
</tbody></table>
<p>如果包含多个文件，那么 grep 命令仅显示发现文件中匹配模式的那些文件名。</p>
<h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>功能：根据脚本命令对文本文件进行流式编辑</p>
<p>操作单位：<strong>行或列（根据脚本指令决定）</strong></p>
<p>结构：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sed [选项] [脚本命令] 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-e 脚本命令</td>
<td align="left">该选项会将其后跟的脚本命令添加到已有的命令中。</td>
</tr>
<tr>
<td align="left">-f 脚本命令文件</td>
<td align="left">该选项会将其后文件中的脚本命令添加到已有的命令中。</td>
</tr>
<tr>
<td align="left">-n</td>
<td align="left">该选项会屏蔽启动输出，需使用 print 命令来完成输出。（默认情况下，sed 会在所有的脚本指定执行完毕后自动输出处理后的所有内容）</td>
</tr>
<tr>
<td align="left">-i</td>
<td align="left">此选项会直接修改源文件，要慎用</td>
</tr>
</tbody></table>
<p>sed 的 [脚本命令] 要比前两种命令的匹配模式复杂一些。</p>
<h5 id="sed-s-词组替换"><a href="#sed-s-词组替换" class="headerlink" title="sed s 词组替换"></a>sed s 词组替换</h5><p>基本格式：</p>
<pre class="line-numbers language-none"><code class="language-none">[address]s&#x2F;pattern&#x2F;replacement&#x2F;flags<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>pattern: 需要替换的内容 replacement：替换的新内容 flags：不同的模式选择</p>
<table>
<thead>
<tr>
<th>flags 标记</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>n</td>
<td>(1~512间的数字)表示字符串到出现第n次时才进行替换</td>
</tr>
<tr>
<td>g</td>
<td>对匹配内容全部(否则仅对第一次匹配替换，相当于默认/1)</td>
</tr>
<tr>
<td>p</td>
<td>当使用-n 禁用输出时，会打印匹配的行；否则默认会标记出现修改的行</td>
</tr>
<tr>
<td>w file</td>
<td>将缓冲区内容写入指定 file 中</td>
</tr>
<tr>
<td>&amp;</td>
<td>用正则表达式匹配内容进行替换</td>
</tr>
<tr>
<td>\n</td>
<td>匹配第 n 个字串</td>
</tr>
<tr>
<td>\</td>
<td>转义（&amp;，\，/）等</td>
</tr>
</tbody></table>
<p>一些用法：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sed &#39;s&#x2F;raw&#x2F;new&#x2F;2&#39; data.txt #表示只替换每行第2次出现的匹配模式
sed &#39;s&#x2F;raw&#x2F;new&#x2F;g&#39; data.txt #替换所有匹配内容
sed -n &#39;s&#x2F;raw&#x2F;new&#x2F;p&#39; data.txt #结束后仅输出发生替换的行
# 使用s替换命令时，对于包含类似文件路径的字符串会比较麻烦，需要对正斜线转义
sed &#39;s&#x2F;\&#x2F;bin\&#x2F;bash\&#x2F;bash&#x2F;\&#x2F;bin\&#x2F;csh&#39; &#x2F;etc&#x2F;passwd #代表 &#x2F;bin&#x2F;bash -&gt; &#x2F;bin&#x2F;csh 的替换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="sed-d-行删除"><a href="#sed-d-行删除" class="headerlink" title="sed d 行删除"></a>sed d 行删除</h5><p>基本格式：</p>
<pre class="line-numbers language-none"><code class="language-none">[addresss]d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>删除文本中的特定行，通过adress指定</p>
<p>如果不指定具体行，那么所有内容都会被删除</p>
<p>一些用法：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sed &#39;4d&#39; data.txt #删除文件中第4行
sed &#39;2,3d&#39; data.txt #删除文件中2，3行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h5 id="sed-a-i-行前后插入"><a href="#sed-a-i-行前后插入" class="headerlink" title="sed a / i 行前后插入"></a>sed a / i 行前后插入</h5><p>a 命令表示在指定行的后面附加一行，i 命令表示在指定行的前面插入一行，两种用法完全相同。</p>
<pre class="line-numbers language-none"><code class="language-none">[address] [n]a(或i) \新文本内容<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>用法：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sed &#39;2i\ This is new Line.\&#39; #在第2行之后插入输入的内容<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h5 id="sed-c-替换脚本命令"><a href="#sed-c-替换脚本命令" class="headerlink" title="sed c 替换脚本命令"></a>sed c 替换脚本命令</h5><p>c 命令对指定行的全部内容替换为指定的字符串</p>
<pre class="line-numbers language-none"><code class="language-none">[address] [n]c\用于替换的新文本<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h5 id="sed-y-字符替换"><a href="#sed-y-字符替换" class="headerlink" title="sed y 字符替换"></a>sed y 字符替换</h5><p>和 sed s 类似，但是可以处理单个字符</p>
<p>唯一不以行为单位的命令</p>
<pre class="line-numbers language-none"><code class="language-none">[address]y&#x2F;inchars&#x2F;outchars&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>转换命令会对 inchars 和 outchars 值进行一对一的映射，即 inchars 中的第一个字符会被转换为 outchars 中的第一个字符，第二个字符会被转换成 outchars 中的第二个字符…。如 sed ‘y/abc/ABC/‘ 会将 a b c 转换为对应的大写</p>
<h2 id="Java-Spring"><a href="#Java-Spring" class="headerlink" title="Java / Spring"></a>Java / Spring</h2><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final 类：该类无法被继承，但不保证成员变量不变</p>
<p>final 方法：该方法不能在子类中被重写</p>
<p>final 变量：该变量不能改变【引用】，并且必须被【初始化】</p>
<h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><h3 id="抽象类与接口的比较"><a href="#抽象类与接口的比较" class="headerlink" title="抽象类与接口的比较"></a>抽象类与接口的比较</h3><p>同：</p>
<ol>
<li><p>都不能被【初始化】。</p>
</li>
<li><p>其实现类（或者子类）只有实现了接口或者抽象类中的【所有方法】才能被实例化</p>
</li>
</ol>
<p>异：</p>
<ol>
<li><p>接口只能有定义不能有实现，而抽象类可以有【实现】；</p>
</li>
<li><p>一个类可以实现【多个】接口。一个类只能继承一个抽象类；</p>
</li>
<li><p>接口强调包含特定功能的【契约】作用，而抽象类决定其继承类的主体【结构】</p>
</li>
</ol>
<h3 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h3><p>Java的Integer包装类在进行自动装箱时，如果数值在-128~127之间，会让该Integer对象直接指向常量池中的缓存地址，而不是用new开辟新的空间。</p>
<h3 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>体现在类成员的权限控制和访问器（Getter，Setter）的使用</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>面向对象的最显著特征</p>
<p>减少了</p>
<p>java不同于C++，不允许多重继承，降低了对象定义的复杂性（但是可以多个接口）</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>Java 运行时动态编译效果的最好体现</p>
<p>使得上层应用可以编写通用的程序而不用关心具体的实现，减少了代码复杂性，具体决定调用哪个方法被推迟到运行时决定，避免了静态编译程序的复杂性</p>
<h3 id="Spring-Data-JPA-和-MyBatis-对比"><a href="#Spring-Data-JPA-和-MyBatis-对比" class="headerlink" title="Spring Data JPA 和 MyBatis 对比"></a>Spring Data JPA 和 MyBatis 对比</h3><p>面向对象 ：面向关系（或数据，过程）</p>
<p>实际对比：Spring Data JPA 和一般的 JAVA 代码编写更加贴合，Repository 的使用更加易于理解和方便，对于简单业务，方法名定义查询方法甚至可以完全避免SQL语句。而 MyBatis 的Mapper 编写相比之下较为繁琐。但是对于复杂查询（比如联表查询），JPA的使用就不如 MyBatis 灵活（必须显式地在实体类中指定对应关系）</p>
<h3 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean 生命周期"></a>Spring Bean 生命周期</h3><p>spring 仅管理单例模式 bean 的生命周期</p>
<h2 id="系统设计思路（分布式）"><a href="#系统设计思路（分布式）" class="headerlink" title="系统设计思路（分布式）"></a>系统设计思路（分布式）</h2><h3 id="高并发的秒杀系统"><a href="#高并发的秒杀系统" class="headerlink" title="高并发的秒杀系统"></a>高并发的秒杀系统</h3><p><strong>CAS</strong>：首先验证库存和库存更新使用sql语句级别的 CAS 方式（版本值）</p>
<p><strong>请求限流</strong>：请求量远远大于资源量的场合，那么大部分请求将是无效请求，尽量让这些请求在抵达数据库前被拒绝。可以使用第三方进行请求限流器，比如使用 redis （令牌桶，漏桶（请求时将当前时间以秒为单位的key写入redis（2秒超时时间），同时间的请求发生时对key值自增，如果达到阈值，返回错误））</p>
<p><strong>区别化限流/库存缓存</strong>：除此之外，由于 redis 的限流措施不一定满足不同商品的流量差别，可以考虑将库存量信息作为 Redis 缓存，由于实际下单仍然保证在数据库CAS完成，通过 Redis 库存缓存来放行请求不会影响业务安全性。</p>
<p><strong>异步</strong>：最后如果想进一步提高并发量，可以考虑请求异步化，下单请求通过限流和库存校验后，将订单任务发给 kafka，请求直接返回，通过消费程序从 kafka 获取下单任务并入库落地，完成后回调反馈给用户订单完成的情况（成功/失败）</p>
<h3 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h3><ul>
<li><strong>一致性（Consistency）：</strong>在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li>
<li><strong>可用性（A）：</strong>保证每个请求不管成功或者失败都有响应。</li>
<li><strong>分区容忍性（P）：</strong>系统中任意信息的丢失或失败不会影响系统的继续运作。</li>
</ul>
<p>ZooKeeper保证CP（极端环境下会丢弃一些请求，进行Leader选举时不可用）</p>
<h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p>定义：基本可用（Basically Available），软状态（Soft），最终一致性三词语的缩写，</p>
<ul>
<li><strong>基本可用：</strong>系统不可预知故障时允许损失部分可用性（延长响应时间等）</li>
<li><strong>软状态：</strong>允许不会影响系统整体可用性的数据中间状态，也就是说，允许系统在不同节点的数据副本之间进行数据同步的过程中存在延时</li>
<li><strong>最终一致性：</strong>最终一致性强调系统中所有数据副本，经过一段时间的同步之后，最终能达到一个一致状态。因此，最终一致性的本质是需要系统最终数据能够达到一致，而不是实时一致。</li>
</ul>
<h2 id="网络-Web"><a href="#网络-Web" class="headerlink" title="网络 Web"></a>网络 Web</h2><h3 id="1-TCP"><a href="#1-TCP" class="headerlink" title="1.TCP"></a>1.TCP</h3><h4 id="头部长度："><a href="#头部长度：" class="headerlink" title="头部长度："></a>头部长度：</h4><p>20字节~60字节</p>
<h4 id="超时重传："><a href="#超时重传：" class="headerlink" title="超时重传："></a>超时重传：</h4><p>发送一个报文段后开启一个计时器，如果没有得到发送的数据报的ACK报文，那么就自动重新发送数据</p>
<h4 id="ARQ协议："><a href="#ARQ协议：" class="headerlink" title="ARQ协议："></a>ARQ协议：</h4><p>自动重传请求（Automatic Repeat reQuest），通过请求接受方重传出错的报文，从而用于在不可靠服务基础上实现可靠信息传输。</p>
<p>分为<strong>停止等待（stop-and-wait）ARQ</strong>协议和<strong>连续ARQ</strong>协议</p>
<p>停止等待ARQ协议可以理解为窗口为1的连续ARQ协议，</p>
<h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP<strong>流量控制</strong></h4><p>通过<strong>滑动窗口</strong></p>
<p>消息<strong>接受方</strong>回馈的确认报文段中除了包含已经确认了哪些数据之外，还会包含自己接受<strong>窗口剩余容量大小</strong><br>那么发送方的发送窗口就不能大于这个数值，从而形成一种双方之间的流量控制效果。</p>
<h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP<strong>拥塞控制</strong></h4><p>发送方的发送窗口除了受接受方接受窗口大小的影响之外，还受拥塞窗口的大小的影响</p>
<p>而拥塞窗口则受网络状态变化根据一定拥塞算法变化，从而变化。</p>
<p>四个拥塞算法</p>
<ul>
<li><strong>慢开始</strong>：TCP连接刚建立时，拥塞窗口从一个较低值开始，每经过一个传输轮次大小<strong>倍数增长</strong>，直到到达<strong>慢开始门限</strong>，然后开始拥塞避免</li>
<li><strong>拥塞避免算法</strong>：窗口到达门限值后从倍数增加变成<strong>线性增加</strong>。如果出现网络超时，<strong>门限大小减半，窗口归初始值，重新慢开始</strong></li>
<li><strong>快重传</strong>：首先要求接受方在收到失序报文时立刻发送上个确认报文的重复确认报文。此外如果发送方连续收到三个重复ack，那么立刻发送丢失的那个报文，然后不等待超时重传直接进入<strong>快恢复</strong></li>
<li><strong>快恢复</strong>：<strong>门限改为窗口大小减半，窗口大小改为门限大小</strong>，直接开始<strong>拥塞避免</strong></li>
</ul>
<h4 id="TCP-可靠运输的实现（连续ARQ协议和超时重传）"><a href="#TCP-可靠运输的实现（连续ARQ协议和超时重传）" class="headerlink" title="TCP 可靠运输的实现（连续ARQ协议和超时重传）"></a>TCP 可靠运输的实现（<strong>连续ARQ</strong>协议和超时重传）</h4><ul>
<li><strong>连续ARQ</strong>协议下，接受方只会发送【<strong>按序收到的数据当中中最大的序号</strong>】，直到超时重传</li>
</ul>
<h4 id="与UDP的对比"><a href="#与UDP的对比" class="headerlink" title="与UDP的对比"></a>与UDP的对比</h4><ul>
<li>连接：无连接与有连接</li>
<li>可靠性：可靠运输与最大努力交付</li>
<li>对数据的处理：不会组织报文（分块或合并）</li>
<li>拥塞控制的有无</li>
<li>开销大小</li>
<li>点对点限定/双工和单工</li>
</ul>
<h3 id="2-HTTP1-0-1-1"><a href="#2-HTTP1-0-1-1" class="headerlink" title="2.HTTP1.0 1.1"></a>2.HTTP1.0 1.1</h3><p>HTTP/1.1 强化了 HTTP1.0+ 的 “keep-alive” 连接。</p>
<p>因为站点局部性，即对某个服务器发起 HTTP 请求的应用很可能在接下来发起更多请求，而 HTTP 基本是一个无状态协议，加上TCP连接的握手消耗以及可能的端口耗尽问题</p>
<p>keep-alive 连接允许 TCP 连接在HTTP事务结束之后仍然将 TCP 连接保持打开状态，这样可以减少消耗。但是由于哑代理问题，即不识别 Connection 含义的代码误转发的报文，会导致客户端第二条请求被忽略并使得服务器连接超时关闭</p>
<p>HTTP/1.1 规定 keep-alive 默认开启，如果显式关闭则显式添加 Connection: close 首部。</p>
<p>并且，HTTP/1.1 允许管道化连接，即客户端不用等到第一条请求响应就可以继续发送其他请求</p>
<h3 id="3-HTTP状态码"><a href="#3-HTTP状态码" class="headerlink" title="3.HTTP状态码"></a>3.HTTP状态码</h3><p>200 OK：请求正常处理并返回</p>
<p>204 NO Content：客户端发给客户端请求得到成功处理并返回，但是没有资源可以返回</p>
<p>206 Patial Content：客户端进行了范围请求。</p>
<p>301 Moved Permanently：永久性重定向，表示请求的资源被分配新的URL。</p>
<p>302 Found：临时性重定向，表示请求的资源被分配了新的URL，但是资源还在。（可能与劫持有关）</p>
<p>303 See Other：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源；</p>
<p>304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；</p>
<p>307 Temporary Redirect：临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；</p>
<p>400 Bad Request：表示请求报文中存在语法错误；</p>
<p><strong>403 Forbidden</strong>：服务器拒绝该次访问（访问权限出现问题）</p>
<p><strong>404 Not Found</strong>：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</p>
<p><strong>500 Inter Server Error：</strong>表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；</p>
<p><strong>503 Server Unavailable：</strong>表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；</p>
<h3 id="4-JWT"><a href="#4-JWT" class="headerlink" title="4.JWT"></a>4.JWT</h3><p>原本的session验证方式：</p>
<p>用户输入用户名密码并通过服务器验证后，服务器在当前session中保存相关数据后，传回用户一个cookie，随后用户每次请求通过这个cookie验证。</p>
<p>坏处是如果存在多台服务器，那么每台服务器都需要存放关于这个用户 session 数据，另外也会消耗内存。</p>
<p>JWT的组成：</p>
<p>Header：签名的算法，类型（JWT令牌统一为JWT）</p>
<p>Payload：存放实际传递的数据</p>
<p>Signature：通过一个只有服务器知道的密钥，组合header和payload进行加密。</p>
<p>特点：</p>
<p>除非另外加逻辑，否则签发后直到失效无法再废止（token的时效被显式写入了token正文，无法主动通过服务器调控）</p>
<h3 id="localhost与127-0-0-1"><a href="#localhost与127-0-0-1" class="headerlink" title="localhost与127.0.0.1"></a>localhost与127.0.0.1</h3><p>127.0.0.1以及localhost（如果hosts文件正常设置情况下）都不会经过网卡等网络设备</p>
<p>原理是：127.0.0.1称为一种特殊的回环地址，如果存在应用使用127.0.0.1时，根据网络协议层级，数据在包装到<strong>网络层</strong>时，如果发现ip为127.0.0.1时，数据将<strong>不再向下包装，而是直接回送给本机的相关应用。</strong></p>
<p>而localhost仅仅只是多了一次在hosts文件中解析域名的过程，解析为127.0.0.1后，原理仍然相同。</p>
<h3 id="所谓的TCP粘包"><a href="#所谓的TCP粘包" class="headerlink" title="所谓的TCP粘包"></a>所谓的TCP粘包</h3><p>TCP保证了<strong>可靠按序传输</strong>，唯一的问题在于送出的数据为流式传输，可能导致<strong>分块发送的数据在被读取前被不合法地切分为或者不合法地整合</strong>等问题；或者<strong>缓冲区数据未被完全发送或者完全接收</strong>等问题</p>
<p>TCP实际是一个流式传输，由于应用逻辑需要所以要进行粘包和拆包，</p>
<p>解决方法：</p>
<p>添加标志位</p>
<p>根据具体应用需要，对读取或发送消息时，通过编程限制，保持信息边界。</p>
<p>比如确保缓冲区内容完全发送的代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int res;
int pos &#x3D; 0; &#x2F;&#x2F;下一次发送需要开始的位置：
while(pos &lt; len)
&#123;
res &#x3D; send(sd, buffer + pos , len - pos, 0);
if(res &lt;&#x3D;0) goto err_handler; &#x2F;&#x2F;去错误处理
pos +&#x3D; res;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="（HTTP环境下的）TCP性能问题"><a href="#（HTTP环境下的）TCP性能问题" class="headerlink" title="（HTTP环境下的）TCP性能问题"></a>（HTTP环境下的）TCP性能问题</h3><h4 id="HTTP事务时延分析"><a href="#HTTP事务时延分析" class="headerlink" title="HTTP事务时延分析"></a>HTTP事务时延分析</h4><p>与建立 TCP 连接，以及传输请求和响应报文的时间相比，事务处理时间可能 是很短的。除非客户端或服务器超载，或正在处理复杂的动态资源，否则 HTTP 时延就是由 TCP 网络时延构成的。</p>
<p>其中，主要时延有以下几点影响因素：</p>
<ul>
<li>URL的DNS解析（一般客户端会有近期站点的缓存）</li>
<li>TCP连接的建立时延</li>
<li>请求报文的传输时延，服务器处理请求的时延，回送报文的传输时延</li>
</ul>
<h4 id="性能聚焦点"><a href="#性能聚焦点" class="headerlink" title="性能聚焦点"></a>性能聚焦点</h4><h5 id="TCP连接的握手时延"><a href="#TCP连接的握手时延" class="headerlink" title="TCP连接的握手时延"></a>TCP连接的握手时延</h5><p>TCP连接时所发送的确认分组在40~60子节左右，加上三次握手。结果是，小的HTTP事务可能会在TCP建立上花费50%或者更多时间。</p>
<h5 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h5><p>TCP为了保证可靠传说具有自己的完整性校验与确认包等机制，由于于确认报文很小，所以 TCP 允许在发往相同方向的输出数据分组中对其进行“捎 带”。所以为了增加这种“捎带”的利用性，许多TCP栈实现了一种“延迟确认”算法：<strong>延迟确认算法会在一个特定的窗口时间（通常是 100 ～ 200 毫 秒）内将输出确认存放在缓冲区中</strong>，以寻找能够捎带它的输出数据分组。</p>
<p>但是，HTTP 具有<strong>双峰特征</strong>的请求 - 应答行为降低了捎带信息的可能。当希望有相反方向回传分组的时候，偏偏没有那么多。所以，这种情况下延迟确认算法反而会引入相当大的时延。根据所使用操作系统的不同，可以调整或禁止延迟确认算法。</p>
<p>在对 TCP 栈的任何参数进行修改之前，一定要对自己在做什么有清醒的认识。TCP 中引入这些算法的目的是防止设计欠佳的应用程序对因特网造成破坏。对 TCP 配置进行的任意修改，都要绝对确保应用程序不会引发这些算法所要避免的问题。</p>
<h5 id="TCP慢启动"><a href="#TCP慢启动" class="headerlink" title="TCP慢启动"></a>TCP慢启动</h5><p>TCP 数据传输的性能还取决于 TCP 连接的使用期（age）。TCP 连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间推移提高传输速度</p>
<p>如果没有重用现存连接的工具。这种机制导致新建立的连接比已经交换一定量数据的连接慢一些。</p>
<h5 id="Nagle算法与TCP-NODELAY"><a href="#Nagle算法与TCP-NODELAY" class="headerlink" title="Nagle算法与TCP_NODELAY"></a>Nagle算法与TCP_NODELAY</h5><p>由于每个TCP段有长达40子节的标记和首部，所以如果 TCP 发送了大量包含少量数据的分组，网络的性能就会严重下降。</p>
<p>Nagle 算法试图在发送一个分组之前，将大量 TCP 数据绑定在一起，以提高网络效率。这种算法鼓励发送全尺寸段，仅当所有其他分组被确认后才允许发送非全尺寸分组。如果其他分组仍然在传输过程中，就将那部分数据缓存起来。只 有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸分组的数据时，才会 将缓存的数据发送出去。</p>
<p>Nagel算法会引发几种HTTP性能问题，首先，<strong>小的HTTP报文会因无法填满一个分组而产生时延</strong>；其次，Nagle 算法与延迟确认之间存在交互问题：<strong>Nagle 算法会阻止数据的发送，直到有确认 分组抵达为止，但确认分组自身会被延迟确认算法延迟 100 ～ 200 毫秒。</strong></p>
<p>HTTP 应用程序常常会在自己的栈中设置参数 TCP_NODELAY，禁用 Nagle 算法， 提高性能。如果要这么做的话，一定要确保会向 TCP 写入大块的数据，这样就不会 产生一堆小分组了。</p>
<h5 id="TIME-WAIT积累与端口耗尽"><a href="#TIME-WAIT积累与端口耗尽" class="headerlink" title="TIME_WAIT积累与端口耗尽"></a>TIME_WAIT积累与端口耗尽</h5><p>当某个 TCP 端点关闭 TCP 连接时，会在内存中维护一个小的控制块，用来记录最 近所关闭连接的 IP 地址和端口号。这类信息只会维持一小段时间，通常是所估计的最大分段使用期的两倍（称为 2MSL，通常为 2 分钟，根据设备设置不同而不同）。</p>
<p>在性能压力基准测试上，通常只有一台或几台用来产生流量的计算机连接到某 系统中去，这样就限制了连接到服务器的客户端 IP 地址数（不能在 2MSL 时间内使用同端口同IP建立连接）。</p>
<p>在客户端IP不变情况下，每次连接到服务器上去时，都会获得一个新的源端口但由于可用源端口的数量有限（比如，60 000 个），而且在 2MSL 秒（比如，120 秒）内连接是无法重用的，<strong>连接率就被限制在了 60 000/120=500 次 / 秒。</strong>超过这个速率发起连接，即使连接用完就释放，也会导致TIME_WAIT端口耗尽问题。</p>
<p>要修正这个问题，可以增加客户端负载生成机器的数量，或 者确保客户端和服务器在循环使用几个虚拟 IP 地址以增加更多的连接组合。</p>
<p>即使没有遇到端口耗尽问题，也要特别小心有大量连接处于打开状态的情况，或为 处于等待状态的连接分配了大量控制块的情况。在有大量打开连接或控制块的情况 下，有些操作系统的速度会严重减缓。</p>
<h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>用户浏览一个正常业务网站A之后，浏览器中保存了相关cookie信息，然后在访问了恶意网站B，B网站页面通过代码，使用用户的Token发起对A的业务操作</p>
<p>解决方法：</p>
<p>验证 <strong>Referer/同源策略</strong>：（Referer需要来自于自己网站的URL）</p>
<p>使用 <strong>JWT</strong>（Json Web Token）：通过Header中存放的JWT进行验证，攻击者无法像获取cookie一样获取到这个内容并发起攻击，再加上SSL加密，使得JWT本身不被截获</p>
<p>设置<strong>httponly</strong>，防止js代码获取cookie</p>
<h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><p>即试图通过一些手段修改正常网页（两种，一种类似SQL/CMD Injection形式，将脚本注入到服务器上，用户访问url时将注入远端js；另一种是外部攻击，直接去尝试通过某种方式修改），使得页面内嵌入指定js代码，访问的用户就会通过用户浏览器自动执行一些恶意js程序，达到攻击者的效果。</p>
<p>如果用户真的不幸成功执行了这些js程序，可以导致访问劫持跳转，提交表单，窃取cookie值等各种结果</p>
<p>解决方法：</p>
<p><strong>过滤与转码</strong>：设计页面时，对敏感标签进行过滤，对于常见控制符进行转码</p>
<p><strong>输入限制</strong>：限制某些可输入项的长度，特殊符号等</p>
<p>使用<strong>现代浏览器</strong>：现代浏览器可以控制js只能访问自己所在网站的资源</p>
<h3 id="HTTPS机制"><a href="#HTTPS机制" class="headerlink" title="HTTPS机制"></a>HTTPS机制</h3><h2 id="数据库（MYSQL-amp-Redis）"><a href="#数据库（MYSQL-amp-Redis）" class="headerlink" title="数据库（MYSQL &amp; Redis）"></a>数据库（MYSQL &amp; Redis）</h2><h3 id="1-MySQL-视图"><a href="#1-MySQL-视图" class="headerlink" title="1.MySQL- 视图"></a>1.MySQL- 视图</h3><p>视图的作用：</p>
<p>简化查询</p>
<p>利于权限控制（比如建立一个开放部分数据的视图，然后再给一个仅能查询该视图的用户）</p>
<h3 id="2-MySQL-存储过程与函数"><a href="#2-MySQL-存储过程与函数" class="headerlink" title="2.MySQL- 存储过程与函数"></a>2.MySQL- 存储过程与函数</h3><p>存储过程（stored procedure）和函数（stored function）统称为stored routines</p>
<p>区别：</p>
<ul>
<li>存储过程实现的功能比函数复杂一些，而函数实现更具有针对性</li>
<li>存储过程可以调用其他存储过程，从而实现复杂操作。但是SQL语句中只能调用函数。</li>
<li>函数可以返回一个表对象，一般作为查询语句的一个部分调用</li>
<li>存储过程可以返回单个或多个结果集以及返回值，甚至错误原因。但函数只能返回一个特定类型值/表对象</li>
<li>存储过程的 CRUD 操作影响数据状态，函数则不能</li>
</ul>
<h3 id="3-MySQL-log"><a href="#3-MySQL-log" class="headerlink" title="3.MySQL log"></a>3.MySQL log</h3><ul>
<li><strong>undolog</strong>(InnoDB)<ul>
<li><strong>回滚</strong>日志文件，用于【事务执行失败】，修改异常等时进行回滚，以及在【MVCC】读中查看数据历史版本。</li>
<li>由 <strong>引擎层 InnoDB</strong> 实现，属于<strong>逻辑日志</strong></li>
<li>记录数据修改被<strong>修改前</strong>的值。如果发生“把 id = ‘B’ 修改为 id = ‘B2’ ”则undo日志就会存放 id = ‘B’ 的记录。这样，如果这个修改出现异常，则可以通过该条undo日志实现回滚操作，保证一致性</li>
<li>当事务提交后，undolog会置于一个待清理的链表中，等到判断没有数据用到该版本信息后再清理。</li>
</ul>
</li>
<li><strong>redolog</strong>(InnoDB)<ul>
<li>重做<strong>日志文件，用于</strong>持久化硬盘。</li>
<li>由 <strong>引擎层 InnoDB</strong> 产生</li>
<li>记录数据被<strong>修改后</strong>的值，属于以页为单位的<strong>物理日志，</strong>记录物理数据页的修改信息，与SQL语句无关。</li>
<li>redolog包含两部分：一是内存中的日志缓冲(<strong>redolog buffer</strong>)，该部分日志是易失性的；二是磁盘上的重做日志文件(<strong>redolog file</strong>)，该部分日志是持久的。将redo日志缓冲刷盘到磁盘文件的策略可以人为指定（<strong>innodb_flush_log_at_trx_commit选项</strong>）</li>
<li>当一条数据需要更新时,InnoDB会先将数据更新，然后记录 redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上。不管是否提交成功都记录，如果回滚了，连回滚的修改也记录，从而保证事务的持久性。</li>
<li>每个InnoDB存储引擎至少有<strong>1个重做日志文件组（group）</strong>，每个文件组下至少有<strong>2个重做日志文件</strong>，如默认的ib_logfile0和ib_logfile1，以循环写入方式运行。用户可以设置多个镜像日志组以提升可用性。</li>
<li>用于【异常宕机】或者【介质故障】的数据恢复</li>
</ul>
</li>
<li><strong>binlog</strong><ul>
<li>由 <strong>MySQL</strong> 上层服务层自身产生，用于记录DML操作。</li>
<li>属于<strong>逻辑日志</strong>，记录发生的SQL语句（DML），仅在事务提交完成后进行一次写入（redo log在事务进行中持续写入）</li>
<li>binlog 从缓存写入磁盘的策略也可以人为指定（<strong>sync_binlog参数</strong>）</li>
<li>可以用于<strong>恢复数据</strong>与<strong>主从复制</strong></li>
</ul>
</li>
</ul>
<h3 id="InnoDB特性"><a href="#InnoDB特性" class="headerlink" title="InnoDB特性"></a>InnoDB特性</h3><p><strong>Insert Buffer</strong>：</p>
<p>对于不在缓冲池的非聚集索引页，不直接插入而是放到Insert Buffer对象中，以一定频率进行Merge</p>
<p><strong>异步IO</strong>：</p>
<p>所有磁盘操作都是异步处理</p>
<p><strong>邻接页刷新</strong>：</p>
<p>刷新脏页时检查该页周围页，如果是脏页一同刷新</p>
<p><strong>自适应哈希索引</strong>：</p>
<p>对某个表进行多次存取后，如果引擎发现使用哈希可以提高性能，那么会将该表索引改为哈希索引</p>
<p><strong>Double Write</strong>：</p>
<p>主要是为了提升数据页可靠性。</p>
<p>仅仅依赖 redo log，如果<strong>写页时发生断裂（内存数据丢失，磁盘页写到一半受损）</strong>，导致页本身的 checksum 等信息丢失，那么无法通过 redolog 修正。所以需要对写页这一步进行类似缓冲备份的的处理</p>
<p>该机制包含两部分存储：磁盘上（2M*1）和内存（1M*2）中。刷新脏页时，先复制到内存的 doublewrite buffer，然后buffer分两次，每次1MB刷到磁盘上的 doublewrite 段，写满后，再从buffer写入对应idb。</p>
<p>如果断裂发生在doublewrite，那么idb是干净的，可以redo恢复。如果断裂发生在idb，那么通过doublewrite备份覆盖idb，然后再redo恢复</p>
<p><strong>MVCC</strong></p>
<ul>
<li><ul>
<li>MVCC多版本并发控制是 <strong>MySQL</strong> 中基于乐观锁理论，用于 Read Commited 和 Repeatable Read 的实现</li>
<li>MySQL中，在表中每条数据后面添加两个字段：最<strong>近修改该行数据的事务ID</strong>，以及<strong>指向该行回滚段（undo</strong> <strong>log表中）的指针</strong>。</li>
<li>引入 <strong>ReadView</strong> 的概念：ReadView 中包含以下四个信息</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><strong>m_ids</strong>：表示在生成readview时，当前系统中活跃的读写事务<strong>id列表</strong>；</li>
<li><strong>min_trx_id</strong>：表示在生成readview时，当前系统中活跃的读写事务中最小的事务id，也就是m_ids中最小的值；</li>
<li><strong>max_trx_id</strong>：表示生成readview时，系统中应该分配给下一个事务的id值；</li>
<li><strong>creator_trx_id</strong>：表示生成该readview的事务的事务id；</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>每次RC与RR的事务读取数据前会按规则产生一个ReadView ：RC在<strong>每次读取数据前</strong>都生成一个 ReadView ，RR在<strong>第一次读取数据前</strong>生成一个 ReadView ，之后一直复用该 ReadView</li>
<li>获得 ReadView 后，按下面的规则按版本链顺序一直搜索到可访问的记录为止：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>1、被访问版本：<strong>trx_id == creator_trx_id**</strong>：<strong>表明当前事务在访问自己修改过的记录，该版本</strong>可以**被当前事务访问；</li>
<li>2、被访问版本：<strong>trx_id &lt; min_trx_id：</strong>表明生成该版本的事务在当前事务生成readview前已经提交，该版本<strong>可以</strong>被当前事务访问；</li>
<li>3、被访问版本： <strong>trx_id &gt;= max_trx_id</strong>，表明生成该版本的事务在当前事务生成readview后才开启，该版本<strong>不可以</strong>被当前事务访问；</li>
<li>4、如果被访问版本的trx_id，<strong>值**</strong>在readview的min_trx_id和max_trx_id之间，就需要判断trx_id属性值是不是在m_ids列表中？**</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>如果<strong>在</strong>：说明创建readview时生成该版本的事务还是活跃的，该版本<strong>不可以</strong>被访问</li>
<li>如果<strong>不在</strong>：说明创建readview时生成该版本的事务已经被提交，该版本<strong>可以</strong>被访问</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="与MyISAM对比"><a href="#与MyISAM对比" class="headerlink" title="与MyISAM对比"></a>与MyISAM对比</h4><table>
<thead>
<tr>
<th>特性</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>事务</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>锁级别</td>
<td>表</td>
<td>行</td>
</tr>
<tr>
<td>索引</td>
<td>索引与内容分离</td>
<td>支持聚簇索引，表内容存储在索引上</td>
</tr>
<tr>
<td>外键支持</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>存储消耗</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>内存消耗</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h3 id="4-Redis-缓存雪崩-缓存穿透"><a href="#4-Redis-缓存雪崩-缓存穿透" class="headerlink" title="4.Redis 缓存雪崩 缓存穿透"></a>4.Redis 缓存雪崩 缓存穿透</h3><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>使用Redis【集群】，保证Redis服务不会挂掉</p>
<p>缓存【时间随机化】处理，避免集体失效</p>
<p>【限流降级】，如果某个服务不可用保证可以有某种备案使用，比如个性推荐服务不可用时换成热点数据推荐服务</p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>接口做一些校验，比如用户本身的【鉴权】以及一些数据合法性的基础校验等</p>
<p>如果某次在缓存和数据库中都没找到某个数据，可以对该值增加一个【key-null值】，并设置较短有效时间</p>
<p>【布隆过滤器】，将所有key可能结果映射到布隆过滤器中，判断存在时才继续向下执行。</p>
<h3 id="5-Redis-的近似-LRU-算法"><a href="#5-Redis-的近似-LRU-算法" class="headerlink" title="5.Redis 的近似 LRU 算法"></a>5.Redis 的近似 LRU 算法</h3><p>由于性能原因，Redis 没有使用真实的 LRU 实现（这需要一个双向链表）</p>
<p>Redis 3.0 之后的做法是，提供一个待候选淘汰的 pool，存在按空闲时间排序默认的 16个 key。每次更新时，从 Redis 键空间随机选择 N 个 key，分别计算他们的空闲时间，仅当 key 在 ( pool 未满 并且 key 的空闲时间 &gt;  pool 中的最小值时，才进入 pool)，然后，选择 pool 中空闲时间最大的 key 淘汰</p>
<h3 id="Redis-分布式锁"><a href="#Redis-分布式锁" class="headerlink" title="Redis 分布式锁"></a>Redis 分布式锁</h3><h3 id="Redis-缓存与DB同步"><a href="#Redis-缓存与DB同步" class="headerlink" title="Redis 缓存与DB同步"></a>Redis 缓存与DB同步</h3><h4 id="基本运行方案：Cache-Aside-Pattern"><a href="#基本运行方案：Cache-Aside-Pattern" class="headerlink" title="基本运行方案：Cache Aside Pattern"></a>基本运行方案：Cache Aside Pattern</h4><ul>
<li>读请求：读缓存，命中直接返回，否则查询DB返回，并将数据set到缓存</li>
<li>写请求：（如果要求强一致可以上对应key读锁）先更新DB，然后直接淘汰对应缓存（如果先淘汰缓存可能有读进程过来读从库数据写入），等待下次 cache miss</li>
</ul>
<h4 id="MySQL触发器-UDF函数（主动推送）"><a href="#MySQL触发器-UDF函数（主动推送）" class="headerlink" title="MySQL触发器 UDF函数（主动推送）"></a>MySQL触发器 UDF函数（主动推送）</h4><ul>
<li>写请求：更新DB，根据触发器主动向redis写入</li>
</ul>
<p>评价：较大程度影响mysql性能，适合读多写少的场景</p>
<h3 id="通过Mysql-binlog-gt-中间件-canal-gt-Redis"><a href="#通过Mysql-binlog-gt-中间件-canal-gt-Redis" class="headerlink" title="通过Mysql binlog -&gt; 中间件(canal) -&gt; Redis"></a>通过Mysql binlog -&gt; 中间件(canal) -&gt; Redis</h3><ul>
<li>写请求：中间件伪装成slave，使master能推送binlog到中间件，中间件解析binlog后写入redis</li>
</ul>
<h3 id="6-数据库主从节点与复制主从表"><a href="#6-数据库主从节点与复制主从表" class="headerlink" title="6.数据库主从节点与复制主从表"></a>6.数据库主从节点与复制主从表</h3><p><img src="https://pic1.zhimg.com/80/v2-1b0c3f31bd398c39b9e0930059b0ca24_hd.jpg" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://pic1.zhimg.com/80/v2-1b0c3f31bd398c39b9e0930059b0ca24_hd.jpg" class="lozad post-image"></p>
<p>对于典型的主从：</p>
<p>三个进程（一个在主节点，两个在从节点）：</p>
<p>​    分别负责发送 bin-log（Log Dump thread），</p>
<p>​    请求 bin-log 并保存在从节点的 relay-log 中（I/O thread），</p>
<p>​    读取 relay-log 并执行（SQL thread）</p>
<p>两个从进程异步进行，互不干扰</p>
<p>主从复制本身存在两种模式：</p>
<p>异步：</p>
<p>​    主节点不主动push binlog，这样可能导致节点没法即时获得最新的 bin-log</p>
<p>半同步：</p>
<p>​    主节点默认情况延时 commit，当至少接收到一台从节点的返回后再commit，否则等待到超时再切换为异步并提交。</p>
<p>​    这样使得bin-log 至少传到了一个从节点上。</p>
<h3 id="7-聚簇索引和非聚簇索引"><a href="#7-聚簇索引和非聚簇索引" class="headerlink" title="7.聚簇索引和非聚簇索引"></a>7.聚簇索引和非聚簇索引</h3><p>如果索引B+树的叶子节点存储了<strong>整行数据</strong>的是主键索引，也被称之为<strong>聚簇索引</strong>。</p>
<p>一张表只能有一个聚簇索引</p>
<p>如果索引B+ Tree的叶子节点存储了<strong>主键的值</strong>的是非主键索引，也被称之为<strong>非聚簇索引</strong></p>
<h3 id="8-Hash索引和B-树索引对比以及应用"><a href="#8-Hash索引和B-树索引对比以及应用" class="headerlink" title="8.Hash索引和B+树索引对比以及应用"></a>8.Hash索引和B+树索引对比以及应用</h3><p>hash索引：</p>
<p>​    等值查找更快</p>
<p>​    不支持模糊擦护照与范围查找</p>
<p>​    性能不稳定</p>
<p>​    必然回表</p>
<p><strong>InnoDB自适应哈希索引：</strong>InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则会在B+树结构的索引基础上建立哈希索引，称之为自适应哈希索引。</p>
<h3 id="9-最左索引原则"><a href="#9-最左索引原则" class="headerlink" title="9.最左索引原则"></a>9.最左索引原则</h3><p>B+树对于联合索引原则上来说通过最左原则匹配，举例来说：对联合索引(a,b,c)，仅当<code>**where a = &#39;xx&#39;**</code> / <code>**where a = &#39;xx&#39; and b = &#39;xx&#39;**</code> / <code>**where a = &#39;xx&#39; and b = &#39;xx&#39; and c = &#39;xx&#39;**</code>三种情况（<strong>a,ab,abc</strong>）会走该索引，否则不走索引</p>
<p>但是存在“例外”，对于 <code>**where b = &#39;xx&#39; and c = &#39;xx&#39;**</code> 比如假设表中只存在 <strong>a b c</strong> 三个字段，查询的所有字段都可以在索引中找到，那么不需要再回表，情况变成了 <strong>覆盖索引</strong> 的情况</p>
<p>除此之外，还可能存在 mysql 隐式的<strong>自动优化</strong>情况：比如在上述例子中可以将 select * from table where b = 18 and c = 170 <strong>改造</strong>成 select * from table where a = ‘男’ and b = 18 and c = 170 union all select * from table where a = ‘女’ and b = 18 and c = 170，这样就可以走索引，但是这种优化是不确定事件，但是是一个需要考虑的因素。</p>
<h3 id="10-Mysql-用户权限管理"><a href="#10-Mysql-用户权限管理" class="headerlink" title="10.Mysql 用户权限管理"></a>10.Mysql 用户权限管理</h3><h2 id="各种小设计，算法等"><a href="#各种小设计，算法等" class="headerlink" title="各种小设计，算法等"></a>各种小设计，算法等</h2><h3 id="撤销反撤销的实现"><a href="#撤销反撤销的实现" class="headerlink" title="撤销反撤销的实现"></a>撤销反撤销的实现</h3><p>维护一个undoStack，reversStack，分别顺序存放正常操作和撤销过的操作</p>
<p>操作、撤销操作分别压栈即可；执行不可回滚操作时，清空undoStack，执行任何操作后清空reversStack</p>
<h3 id="各类算法排序速度"><a href="#各类算法排序速度" class="headerlink" title="各类算法排序速度"></a>各类算法排序速度</h3><p><img src="https://cdn.jsdelivr.net/gh/syameimarukibou/imagebox/img/image-20210320232649291.png" alt="image-20210320232649291" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://cdn.jsdelivr.net/gh/syameimarukibou/imagebox/img/image-20210320232649291.png" class="lozad post-image"></p>
<h4 id="快排基准元素的选择"><a href="#快排基准元素的选择" class="headerlink" title="快排基准元素的选择"></a>快排基准元素的选择</h4><p>如果选择随机一个元素作为基准点，那么在非特殊情况下的排序，出现最坏情况的概率大概为 1/(N*N)</p>
<p><strong>当重复元素非常多时</strong>：序列很容易被划分为两个极不平衡的列，导致算法复杂度退化。这个时候可以采取<strong>两路快排</strong>的方式：【通过两个指针将i, j分为 &lt;=V 和 &gt;= V 两个部分，两侧都找到第一个不符合规则的元素（包括相等元素）的时候，交换这两个元素然后继续循环执行这个过程直到指针相遇】，这样至少可以保证在中部存在大量相等元素时两个指针可以互相向中部靠拢</p>

  </div>
  <div>
  
  <div class="post-note note-warning copyright" style="margin-top: 42px">
    <p><span style="font-weight: bold;">作者：</span><a target="_blank" rel="nofollow noopener noreferrer" href="https://syameimarukibou.github.io/about">Kibou</a></p>
    <p><span style="font-weight: bold;">文章链接：</span><a target="_blank" rel="nofollow noopener noreferrer" href="https://syameimarukibou.github.io/2021/03/14/interview-points/">https://syameimarukibou.github.io/2021/03/14/interview-points/</a></p>
    <p><span style="font-weight: bold;">版权声明：</span>本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 协议</a>。转载请注明出处！</p>
  </div>
  
  </div>
</article>
<div class="nav">
  
  <div class="nav-item-prev">
    <a href="/2021/03/14/useful-websites/" class="nav-link">
      <i class="iconfont icon-left nav-prev-icon"></i>
      <div>
        <div class="nav-label">上一篇</div>
        
        <div class="nav-title">实用网站与应用分享（一） </div>
        
      </div>
    </a>
  </div>
  
  
  <div class="nav-item-next">
    <a href="/2021/03/05/hexo-deploy-tarvis/" class="nav-link">
      <div>
        <div class="nav-label">下一篇</div>
        
        <div class="nav-title">使用 Hexo + Github Pages + Travis 自动部署个人博客 </div>
        
      </div>
      <i class="iconfont icon-right nav-next-icon"></i>
    </a>
  </div>
  
</div>

<div class="card card-content comment-card" style="margin-top: 16px;">
  <div class="comment-card-title">评论</div>
  
  <div id="lv-container" data-id="city" data-uid="MTAyMC81Mjg5OS8yOTM3Ng==">
    <script>
      (function (d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') {
          return;
        }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.defer = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  </div>

</div>

<div class="card card-content toc-card" id="mobiletoc">
  <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与进程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">线程安全的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%8E%AA%E6%96%BD"><span class="toc-text">线程同步措施</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AF"><span class="toc-text">线程通讯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6"><span class="toc-text">调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%AD%BB%E9%94%81%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">1. 死锁四个必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86"><span class="toc-text">2. synchronized 关键字原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E9%94%81"><span class="toc-text">轻量锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-text">偏向锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-volatile-%E4%BD%9C%E7%94%A8"><span class="toc-text">3. volatile 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ReentrantLock-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">4. ReentrantLock 实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-HashMap-%E5%AE%9E%E7%8E%B0"><span class="toc-text">5. HashMap 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8-%E5%8F%98%E5%8A%A8"><span class="toc-text">JDK1.8 变动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E6%8E%AA%E6%96%BD"><span class="toc-text">哈希冲突措施</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-ConcurrentHashMap-%E5%AE%9E%E7%8E%B0"><span class="toc-text">6. ConcurrentHashMap 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-7%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">JDK1.7实现：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">JDK1.8实现：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">7. 线程 &#x2F; 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">线程的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-text">线程的创建方式与区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E7%A7%8D%E7%B1%BB%E5%92%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">线程池的参数，种类和使用的好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-ThreadLocal-%E5%92%8C-Inherittable"><span class="toc-text">8. ThreadLocal 和 Inherittable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal-%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%A7%E8%87%B4%E7%90%86%E8%A7%A3"><span class="toc-text">ThreadLocal 的简单大致理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E7%A7%8DIO%E4%BB%A5%E5%8F%8A-select-poll-epoll"><span class="toc-text">5种IO以及 select poll epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E7%A7%8DIO"><span class="toc-text">5种IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select-poll-epoll"><span class="toc-text">select poll epoll</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-text">1. 运行时内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-text">虚拟机栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA-%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%88%E5%85%B1%E4%BA%AB%EF%BC%89"><span class="toc-text">方法区&#x2F;元空间（共享）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-text">直接内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%EF%BC%88%E5%85%B1%E4%BA%AB%EF%BC%89"><span class="toc-text">堆（共享）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">2. 对象创建与内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-text">对象分配过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ETLAB"><span class="toc-text">关于TLAB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">对象内存分配的两种方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1GC%E5%90%8E%E7%9A%84%E7%A7%BB%E5%8A%A8%E9%A1%BA%E5%BA%8F"><span class="toc-text">对象GC后的移动顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-text">3. 内存回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%BA%9F%E5%BC%83%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-text">判断对象废弃的方法（垃圾回收机制）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-text">分代回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS%EF%BC%8CG1"><span class="toc-text">CMS，G1</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CMS%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">CMS执行过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">G1执行过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1%E4%B8%8ECMS%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">G1与CMS的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-text">4. 类加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux"><span class="toc-text">Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Linux%E4%B8%8E%E6%9F%A5%E7%9C%8B%E8%B5%84%E6%BA%90%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-text">1. Linux与查看资源相关的指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ps-%E8%BF%9B%E7%A8%8B"><span class="toc-text">ps 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#top-%E8%BF%9B%E7%A8%8B"><span class="toc-text">top 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pgrep-%E8%BF%9B%E7%A8%8B"><span class="toc-text">pgrep 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free-%E5%86%85%E5%AD%98"><span class="toc-text">free 内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#proc-meminfo-%E5%86%85%E5%AD%98"><span class="toc-text">&#x2F;proc&#x2F;meminfo 内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vmstat-%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="toc-text">vmstat 基本状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lsof-i-%E7%BD%91%E7%BB%9C"><span class="toc-text">lsof -i 网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#netstat-%E7%BD%91%E7%BB%9C"><span class="toc-text">netstat 网络</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AElog%E4%B8%AD-%E8%AE%BF%E9%97%AE%E8%AE%B0%E5%BD%95%E6%9C%80%E5%A4%9A%E7%9A%84%E5%89%8D10%E4%B8%AAip%EF%BC%9F"><span class="toc-text">2 如何获取一个网络访问log中 访问记录最多的前10个ip？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Linux-%E5%B8%B8%E7%94%A8%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C-grep-sed-awk"><span class="toc-text">3. Linux 常用文本处理操作 grep sed awk</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#awk"><span class="toc-text">awk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#grep"><span class="toc-text">grep</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sed"><span class="toc-text">sed</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sed-s-%E8%AF%8D%E7%BB%84%E6%9B%BF%E6%8D%A2"><span class="toc-text">sed s 词组替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sed-d-%E8%A1%8C%E5%88%A0%E9%99%A4"><span class="toc-text">sed d 行删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sed-a-i-%E8%A1%8C%E5%89%8D%E5%90%8E%E6%8F%92%E5%85%A5"><span class="toc-text">sed a &#x2F; i 行前后插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sed-c-%E6%9B%BF%E6%8D%A2%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">sed c 替换脚本命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sed-y-%E5%AD%97%E7%AC%A6%E6%9B%BF%E6%8D%A2"><span class="toc-text">sed y 字符替换</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Spring"><span class="toc-text">Java &#x2F; Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">final关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">static 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">抽象类与接口的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">基本类型包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Data-JPA-%E5%92%8C-MyBatis-%E5%AF%B9%E6%AF%94"><span class="toc-text">Spring Data JPA 和 MyBatis 对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Spring Bean 生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%89"><span class="toc-text">系统设计思路（分布式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F"><span class="toc-text">高并发的秒杀系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP-%E5%AE%9A%E7%90%86"><span class="toc-text">CAP 定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BASE%E7%90%86%E8%AE%BA"><span class="toc-text">BASE理论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C-Web"><span class="toc-text">网络 Web</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-TCP"><span class="toc-text">1.TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E9%83%A8%E9%95%BF%E5%BA%A6%EF%BC%9A"><span class="toc-text">头部长度：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%EF%BC%9A"><span class="toc-text">超时重传：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARQ%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="toc-text">ARQ协议：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">TCP流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text">TCP拥塞控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%8F%AF%E9%9D%A0%E8%BF%90%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE%E5%92%8C%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%EF%BC%89"><span class="toc-text">TCP 可靠运输的实现（连续ARQ协议和超时重传）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8EUDP%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">与UDP的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-HTTP1-0-1-1"><span class="toc-text">2.HTTP1.0 1.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">3.HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-JWT"><span class="toc-text">4.JWT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#localhost%E4%B8%8E127-0-0-1"><span class="toc-text">localhost与127.0.0.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E8%B0%93%E7%9A%84TCP%E7%B2%98%E5%8C%85"><span class="toc-text">所谓的TCP粘包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88HTTP%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%EF%BC%89TCP%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-text">（HTTP环境下的）TCP性能问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E4%BA%8B%E5%8A%A1%E6%97%B6%E5%BB%B6%E5%88%86%E6%9E%90"><span class="toc-text">HTTP事务时延分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%81%9A%E7%84%A6%E7%82%B9"><span class="toc-text">性能聚焦点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%8F%A1%E6%89%8B%E6%97%B6%E5%BB%B6"><span class="toc-text">TCP连接的握手时延</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4"><span class="toc-text">延迟确认</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-text">TCP慢启动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Nagle%E7%AE%97%E6%B3%95%E4%B8%8ETCP-NODELAY"><span class="toc-text">Nagle算法与TCP_NODELAY</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TIME-WAIT%E7%A7%AF%E7%B4%AF%E4%B8%8E%E7%AB%AF%E5%8F%A3%E8%80%97%E5%B0%BD"><span class="toc-text">TIME_WAIT积累与端口耗尽</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF%E6%94%BB%E5%87%BB"><span class="toc-text">CSRF攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS%E6%94%BB%E5%87%BB"><span class="toc-text">XSS攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E6%9C%BA%E5%88%B6"><span class="toc-text">HTTPS机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88MYSQL-amp-Redis%EF%BC%89"><span class="toc-text">数据库（MYSQL &amp; Redis）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-MySQL-%E8%A7%86%E5%9B%BE"><span class="toc-text">1.MySQL- 视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MySQL-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-text">2.MySQL- 存储过程与函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-MySQL-log"><span class="toc-text">3.MySQL log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E7%89%B9%E6%80%A7"><span class="toc-text">InnoDB特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8EMyISAM%E5%AF%B9%E6%AF%94"><span class="toc-text">与MyISAM对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Redis-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">4.Redis 缓存雪崩 缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">缓存穿透</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Redis-%E7%9A%84%E8%BF%91%E4%BC%BC-LRU-%E7%AE%97%E6%B3%95"><span class="toc-text">5.Redis 的近似 LRU 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">Redis 分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%BC%93%E5%AD%98%E4%B8%8EDB%E5%90%8C%E6%AD%A5"><span class="toc-text">Redis 缓存与DB同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%90%E8%A1%8C%E6%96%B9%E6%A1%88%EF%BC%9ACache-Aside-Pattern"><span class="toc-text">基本运行方案：Cache Aside Pattern</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E8%A7%A6%E5%8F%91%E5%99%A8-UDF%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81%EF%BC%89"><span class="toc-text">MySQL触发器 UDF函数（主动推送）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Mysql-binlog-gt-%E4%B8%AD%E9%97%B4%E4%BB%B6-canal-gt-Redis"><span class="toc-text">通过Mysql binlog -&gt; 中间件(canal) -&gt; Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9%E4%B8%8E%E5%A4%8D%E5%88%B6%E4%B8%BB%E4%BB%8E%E8%A1%A8"><span class="toc-text">6.数据库主从节点与复制主从表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">7.聚簇索引和非聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Hash%E7%B4%A2%E5%BC%95%E5%92%8CB-%E6%A0%91%E7%B4%A2%E5%BC%95%E5%AF%B9%E6%AF%94%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="toc-text">8.Hash索引和B+树索引对比以及应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%9C%80%E5%B7%A6%E7%B4%A2%E5%BC%95%E5%8E%9F%E5%88%99"><span class="toc-text">9.最左索引原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Mysql-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-text">10.Mysql 用户权限管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%B0%8F%E8%AE%BE%E8%AE%A1%EF%BC%8C%E7%AE%97%E6%B3%95%E7%AD%89"><span class="toc-text">各种小设计，算法等</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E5%8F%8D%E6%92%A4%E9%94%80%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">撤销反撤销的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%B1%BB%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E9%80%9F%E5%BA%A6"><span class="toc-text">各类算法排序速度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%8E%92%E5%9F%BA%E5%87%86%E5%85%83%E7%B4%A0%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">快排基准元素的选择</span></a></li></ol></li></ol></li></ol>
</div></main>
          <aside class="left-column">
            
            <div class="card card-author">
              
<img src="/img/author_icon.png" class="author-img">

<p class="author-name">Kibou</p>
<p class="author-description">因为相信而竭尽全力的普通人 <p class="author-description"><a href="/about">关于我</a></p></p>
<div class="author-message">
  <a class="author-posts-count" href="/archives">
    <span>7</span>
    <span>文章</span>
  </a>
  <a class="author-categories-count" href="/categories">
    <span>6</span>
    <span>分类</span>
  </a>
  <a class="author-tags-count" href="/tags">
    <span>13</span>
    <span>标签</span>
  </a>
</div>

            </div>
            
            <div class="sticky-tablet">
  
  
  <article class="display-when-two-columns spacer">
    <div class="card card-content toc-card">
      <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与进程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">线程安全的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%8E%AA%E6%96%BD"><span class="toc-text">线程同步措施</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AF"><span class="toc-text">线程通讯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6"><span class="toc-text">调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%AD%BB%E9%94%81%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">1. 死锁四个必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86"><span class="toc-text">2. synchronized 关键字原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E9%94%81"><span class="toc-text">轻量锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-text">偏向锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-volatile-%E4%BD%9C%E7%94%A8"><span class="toc-text">3. volatile 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ReentrantLock-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">4. ReentrantLock 实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-HashMap-%E5%AE%9E%E7%8E%B0"><span class="toc-text">5. HashMap 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8-%E5%8F%98%E5%8A%A8"><span class="toc-text">JDK1.8 变动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E6%8E%AA%E6%96%BD"><span class="toc-text">哈希冲突措施</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-ConcurrentHashMap-%E5%AE%9E%E7%8E%B0"><span class="toc-text">6. ConcurrentHashMap 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-7%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">JDK1.7实现：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">JDK1.8实现：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">7. 线程 &#x2F; 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">线程的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-text">线程的创建方式与区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E7%A7%8D%E7%B1%BB%E5%92%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">线程池的参数，种类和使用的好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-ThreadLocal-%E5%92%8C-Inherittable"><span class="toc-text">8. ThreadLocal 和 Inherittable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal-%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%A7%E8%87%B4%E7%90%86%E8%A7%A3"><span class="toc-text">ThreadLocal 的简单大致理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E7%A7%8DIO%E4%BB%A5%E5%8F%8A-select-poll-epoll"><span class="toc-text">5种IO以及 select poll epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E7%A7%8DIO"><span class="toc-text">5种IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select-poll-epoll"><span class="toc-text">select poll epoll</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-text">1. 运行时内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-text">虚拟机栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA-%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%88%E5%85%B1%E4%BA%AB%EF%BC%89"><span class="toc-text">方法区&#x2F;元空间（共享）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-text">直接内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%EF%BC%88%E5%85%B1%E4%BA%AB%EF%BC%89"><span class="toc-text">堆（共享）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">2. 对象创建与内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-text">对象分配过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ETLAB"><span class="toc-text">关于TLAB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">对象内存分配的两种方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1GC%E5%90%8E%E7%9A%84%E7%A7%BB%E5%8A%A8%E9%A1%BA%E5%BA%8F"><span class="toc-text">对象GC后的移动顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-text">3. 内存回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%BA%9F%E5%BC%83%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-text">判断对象废弃的方法（垃圾回收机制）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-text">分代回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS%EF%BC%8CG1"><span class="toc-text">CMS，G1</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CMS%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">CMS执行过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">G1执行过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1%E4%B8%8ECMS%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">G1与CMS的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-text">4. 类加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux"><span class="toc-text">Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Linux%E4%B8%8E%E6%9F%A5%E7%9C%8B%E8%B5%84%E6%BA%90%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-text">1. Linux与查看资源相关的指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ps-%E8%BF%9B%E7%A8%8B"><span class="toc-text">ps 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#top-%E8%BF%9B%E7%A8%8B"><span class="toc-text">top 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pgrep-%E8%BF%9B%E7%A8%8B"><span class="toc-text">pgrep 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free-%E5%86%85%E5%AD%98"><span class="toc-text">free 内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#proc-meminfo-%E5%86%85%E5%AD%98"><span class="toc-text">&#x2F;proc&#x2F;meminfo 内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vmstat-%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="toc-text">vmstat 基本状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lsof-i-%E7%BD%91%E7%BB%9C"><span class="toc-text">lsof -i 网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#netstat-%E7%BD%91%E7%BB%9C"><span class="toc-text">netstat 网络</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AElog%E4%B8%AD-%E8%AE%BF%E9%97%AE%E8%AE%B0%E5%BD%95%E6%9C%80%E5%A4%9A%E7%9A%84%E5%89%8D10%E4%B8%AAip%EF%BC%9F"><span class="toc-text">2 如何获取一个网络访问log中 访问记录最多的前10个ip？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Linux-%E5%B8%B8%E7%94%A8%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C-grep-sed-awk"><span class="toc-text">3. Linux 常用文本处理操作 grep sed awk</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#awk"><span class="toc-text">awk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#grep"><span class="toc-text">grep</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sed"><span class="toc-text">sed</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sed-s-%E8%AF%8D%E7%BB%84%E6%9B%BF%E6%8D%A2"><span class="toc-text">sed s 词组替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sed-d-%E8%A1%8C%E5%88%A0%E9%99%A4"><span class="toc-text">sed d 行删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sed-a-i-%E8%A1%8C%E5%89%8D%E5%90%8E%E6%8F%92%E5%85%A5"><span class="toc-text">sed a &#x2F; i 行前后插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sed-c-%E6%9B%BF%E6%8D%A2%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">sed c 替换脚本命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sed-y-%E5%AD%97%E7%AC%A6%E6%9B%BF%E6%8D%A2"><span class="toc-text">sed y 字符替换</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Spring"><span class="toc-text">Java &#x2F; Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">final关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">static 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">抽象类与接口的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">基本类型包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Data-JPA-%E5%92%8C-MyBatis-%E5%AF%B9%E6%AF%94"><span class="toc-text">Spring Data JPA 和 MyBatis 对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Spring Bean 生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%89"><span class="toc-text">系统设计思路（分布式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F"><span class="toc-text">高并发的秒杀系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP-%E5%AE%9A%E7%90%86"><span class="toc-text">CAP 定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BASE%E7%90%86%E8%AE%BA"><span class="toc-text">BASE理论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C-Web"><span class="toc-text">网络 Web</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-TCP"><span class="toc-text">1.TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E9%83%A8%E9%95%BF%E5%BA%A6%EF%BC%9A"><span class="toc-text">头部长度：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%EF%BC%9A"><span class="toc-text">超时重传：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARQ%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="toc-text">ARQ协议：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">TCP流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text">TCP拥塞控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%8F%AF%E9%9D%A0%E8%BF%90%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE%E5%92%8C%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%EF%BC%89"><span class="toc-text">TCP 可靠运输的实现（连续ARQ协议和超时重传）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8EUDP%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">与UDP的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-HTTP1-0-1-1"><span class="toc-text">2.HTTP1.0 1.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">3.HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-JWT"><span class="toc-text">4.JWT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#localhost%E4%B8%8E127-0-0-1"><span class="toc-text">localhost与127.0.0.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E8%B0%93%E7%9A%84TCP%E7%B2%98%E5%8C%85"><span class="toc-text">所谓的TCP粘包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88HTTP%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%EF%BC%89TCP%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-text">（HTTP环境下的）TCP性能问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E4%BA%8B%E5%8A%A1%E6%97%B6%E5%BB%B6%E5%88%86%E6%9E%90"><span class="toc-text">HTTP事务时延分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%81%9A%E7%84%A6%E7%82%B9"><span class="toc-text">性能聚焦点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%8F%A1%E6%89%8B%E6%97%B6%E5%BB%B6"><span class="toc-text">TCP连接的握手时延</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4"><span class="toc-text">延迟确认</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-text">TCP慢启动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Nagle%E7%AE%97%E6%B3%95%E4%B8%8ETCP-NODELAY"><span class="toc-text">Nagle算法与TCP_NODELAY</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TIME-WAIT%E7%A7%AF%E7%B4%AF%E4%B8%8E%E7%AB%AF%E5%8F%A3%E8%80%97%E5%B0%BD"><span class="toc-text">TIME_WAIT积累与端口耗尽</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF%E6%94%BB%E5%87%BB"><span class="toc-text">CSRF攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS%E6%94%BB%E5%87%BB"><span class="toc-text">XSS攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E6%9C%BA%E5%88%B6"><span class="toc-text">HTTPS机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88MYSQL-amp-Redis%EF%BC%89"><span class="toc-text">数据库（MYSQL &amp; Redis）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-MySQL-%E8%A7%86%E5%9B%BE"><span class="toc-text">1.MySQL- 视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MySQL-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-text">2.MySQL- 存储过程与函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-MySQL-log"><span class="toc-text">3.MySQL log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E7%89%B9%E6%80%A7"><span class="toc-text">InnoDB特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8EMyISAM%E5%AF%B9%E6%AF%94"><span class="toc-text">与MyISAM对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Redis-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">4.Redis 缓存雪崩 缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">缓存穿透</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Redis-%E7%9A%84%E8%BF%91%E4%BC%BC-LRU-%E7%AE%97%E6%B3%95"><span class="toc-text">5.Redis 的近似 LRU 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">Redis 分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%BC%93%E5%AD%98%E4%B8%8EDB%E5%90%8C%E6%AD%A5"><span class="toc-text">Redis 缓存与DB同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%90%E8%A1%8C%E6%96%B9%E6%A1%88%EF%BC%9ACache-Aside-Pattern"><span class="toc-text">基本运行方案：Cache Aside Pattern</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E8%A7%A6%E5%8F%91%E5%99%A8-UDF%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81%EF%BC%89"><span class="toc-text">MySQL触发器 UDF函数（主动推送）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Mysql-binlog-gt-%E4%B8%AD%E9%97%B4%E4%BB%B6-canal-gt-Redis"><span class="toc-text">通过Mysql binlog -&gt; 中间件(canal) -&gt; Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9%E4%B8%8E%E5%A4%8D%E5%88%B6%E4%B8%BB%E4%BB%8E%E8%A1%A8"><span class="toc-text">6.数据库主从节点与复制主从表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">7.聚簇索引和非聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Hash%E7%B4%A2%E5%BC%95%E5%92%8CB-%E6%A0%91%E7%B4%A2%E5%BC%95%E5%AF%B9%E6%AF%94%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="toc-text">8.Hash索引和B+树索引对比以及应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%9C%80%E5%B7%A6%E7%B4%A2%E5%BC%95%E5%8E%9F%E5%88%99"><span class="toc-text">9.最左索引原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Mysql-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-text">10.Mysql 用户权限管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%B0%8F%E8%AE%BE%E8%AE%A1%EF%BC%8C%E7%AE%97%E6%B3%95%E7%AD%89"><span class="toc-text">各种小设计，算法等</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E5%8F%8D%E6%92%A4%E9%94%80%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">撤销反撤销的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%B1%BB%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E9%80%9F%E5%BA%A6"><span class="toc-text">各类算法排序速度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%8E%92%E5%9F%BA%E5%87%86%E5%85%83%E7%B4%A0%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">快排基准元素的选择</span></a></li></ol></li></ol></li></ol>
    </div>
  </article>
  
  
  <article class="card card-content">
    <div class="categories-card">
  <div class="categories-header"><i class="iconfont icon-fenlei" style="padding-right: 2px;"></i>分类</div>
  <div class="categories-list">
    
      <a href="/categories/算法练习">
        <div class="categories-list-item">
          算法练习
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/实用工具">
        <div class="categories-list-item">
          实用工具
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/编程思想">
        <div class="categories-list-item">
          编程思想
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/C++">
        <div class="categories-list-item">
          C++
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/面试经验">
        <div class="categories-list-item">
          面试经验
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/MySQL">
        <div class="categories-list-item">
          MySQL
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content">
    <div class="tags-card">
  <div class="tags-header"><i class="iconfont icon-biaoqian" style="padding-right: 2px;"></i>热门标签</div>
  <div class="tags-list">
    
    <a href="\tags\算法" title="算法"><div class="tags-list-item">算法</div></a>
    
    <a href="\tags\hexo" title="hexo"><div class="tags-list-item">hexo</div></a>
    
    <a href="\tags\CI/CD" title="CI/CD"><div class="tags-list-item">CI/CD</div></a>
    
    <a href="\tags\实用工具" title="实用工具"><div class="tags-list-item">实用工具</div></a>
    
    <a href="\tags\Java" title="Java"><div class="tags-list-item">Java</div></a>
    
    <a href="\tags\读书笔记" title="读书笔记"><div class="tags-list-item">读书笔记</div></a>
    
    <a href="\tags\gaming server" title="gaming server"><div class="tags-list-item">gaming server</div></a>
    
    <a href="\tags\C++" title="C++"><div class="tags-list-item">C++</div></a>
    
    <a href="\tags\编程思想" title="编程思想"><div class="tags-list-item">编程思想</div></a>
    
    <a href="\tags\Linux" title="Linux"><div class="tags-list-item">Linux</div></a>
    
    <a href="\tags\MySQL" title="MySQL"><div class="tags-list-item">MySQL</div></a>
    
    <a href="\tags\Redis" title="Redis"><div class="tags-list-item">Redis</div></a>
    
    <a href="\tags\InnoDB" title="InnoDB"><div class="tags-list-item">InnoDB</div></a>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
          <aside class="right-column">
            <div class="sticky-widescreen">
  
  
  <article class="card card-content toc-card">
    <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与进程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">线程安全的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%8E%AA%E6%96%BD"><span class="toc-text">线程同步措施</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AF"><span class="toc-text">线程通讯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6"><span class="toc-text">调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%AD%BB%E9%94%81%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">1. 死锁四个必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86"><span class="toc-text">2. synchronized 关键字原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E9%94%81"><span class="toc-text">轻量锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-text">偏向锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-volatile-%E4%BD%9C%E7%94%A8"><span class="toc-text">3. volatile 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ReentrantLock-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">4. ReentrantLock 实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-HashMap-%E5%AE%9E%E7%8E%B0"><span class="toc-text">5. HashMap 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8-%E5%8F%98%E5%8A%A8"><span class="toc-text">JDK1.8 变动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E6%8E%AA%E6%96%BD"><span class="toc-text">哈希冲突措施</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-ConcurrentHashMap-%E5%AE%9E%E7%8E%B0"><span class="toc-text">6. ConcurrentHashMap 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-7%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">JDK1.7实现：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">JDK1.8实现：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">7. 线程 &#x2F; 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">线程的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-text">线程的创建方式与区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E7%A7%8D%E7%B1%BB%E5%92%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">线程池的参数，种类和使用的好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-ThreadLocal-%E5%92%8C-Inherittable"><span class="toc-text">8. ThreadLocal 和 Inherittable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal-%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%A7%E8%87%B4%E7%90%86%E8%A7%A3"><span class="toc-text">ThreadLocal 的简单大致理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E7%A7%8DIO%E4%BB%A5%E5%8F%8A-select-poll-epoll"><span class="toc-text">5种IO以及 select poll epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E7%A7%8DIO"><span class="toc-text">5种IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select-poll-epoll"><span class="toc-text">select poll epoll</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-text">1. 运行时内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-text">虚拟机栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA-%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%88%E5%85%B1%E4%BA%AB%EF%BC%89"><span class="toc-text">方法区&#x2F;元空间（共享）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-text">直接内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%EF%BC%88%E5%85%B1%E4%BA%AB%EF%BC%89"><span class="toc-text">堆（共享）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">2. 对象创建与内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-text">对象分配过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ETLAB"><span class="toc-text">关于TLAB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">对象内存分配的两种方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1GC%E5%90%8E%E7%9A%84%E7%A7%BB%E5%8A%A8%E9%A1%BA%E5%BA%8F"><span class="toc-text">对象GC后的移动顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-text">3. 内存回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%BA%9F%E5%BC%83%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-text">判断对象废弃的方法（垃圾回收机制）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-text">分代回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS%EF%BC%8CG1"><span class="toc-text">CMS，G1</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CMS%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">CMS执行过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">G1执行过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1%E4%B8%8ECMS%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">G1与CMS的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-text">4. 类加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux"><span class="toc-text">Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Linux%E4%B8%8E%E6%9F%A5%E7%9C%8B%E8%B5%84%E6%BA%90%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-text">1. Linux与查看资源相关的指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ps-%E8%BF%9B%E7%A8%8B"><span class="toc-text">ps 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#top-%E8%BF%9B%E7%A8%8B"><span class="toc-text">top 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pgrep-%E8%BF%9B%E7%A8%8B"><span class="toc-text">pgrep 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free-%E5%86%85%E5%AD%98"><span class="toc-text">free 内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#proc-meminfo-%E5%86%85%E5%AD%98"><span class="toc-text">&#x2F;proc&#x2F;meminfo 内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vmstat-%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="toc-text">vmstat 基本状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lsof-i-%E7%BD%91%E7%BB%9C"><span class="toc-text">lsof -i 网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#netstat-%E7%BD%91%E7%BB%9C"><span class="toc-text">netstat 网络</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AElog%E4%B8%AD-%E8%AE%BF%E9%97%AE%E8%AE%B0%E5%BD%95%E6%9C%80%E5%A4%9A%E7%9A%84%E5%89%8D10%E4%B8%AAip%EF%BC%9F"><span class="toc-text">2 如何获取一个网络访问log中 访问记录最多的前10个ip？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Linux-%E5%B8%B8%E7%94%A8%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C-grep-sed-awk"><span class="toc-text">3. Linux 常用文本处理操作 grep sed awk</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#awk"><span class="toc-text">awk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#grep"><span class="toc-text">grep</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sed"><span class="toc-text">sed</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sed-s-%E8%AF%8D%E7%BB%84%E6%9B%BF%E6%8D%A2"><span class="toc-text">sed s 词组替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sed-d-%E8%A1%8C%E5%88%A0%E9%99%A4"><span class="toc-text">sed d 行删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sed-a-i-%E8%A1%8C%E5%89%8D%E5%90%8E%E6%8F%92%E5%85%A5"><span class="toc-text">sed a &#x2F; i 行前后插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sed-c-%E6%9B%BF%E6%8D%A2%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">sed c 替换脚本命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sed-y-%E5%AD%97%E7%AC%A6%E6%9B%BF%E6%8D%A2"><span class="toc-text">sed y 字符替换</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Spring"><span class="toc-text">Java &#x2F; Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">final关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">static 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">抽象类与接口的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">基本类型包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Data-JPA-%E5%92%8C-MyBatis-%E5%AF%B9%E6%AF%94"><span class="toc-text">Spring Data JPA 和 MyBatis 对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Spring Bean 生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%89"><span class="toc-text">系统设计思路（分布式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F"><span class="toc-text">高并发的秒杀系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP-%E5%AE%9A%E7%90%86"><span class="toc-text">CAP 定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BASE%E7%90%86%E8%AE%BA"><span class="toc-text">BASE理论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C-Web"><span class="toc-text">网络 Web</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-TCP"><span class="toc-text">1.TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E9%83%A8%E9%95%BF%E5%BA%A6%EF%BC%9A"><span class="toc-text">头部长度：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%EF%BC%9A"><span class="toc-text">超时重传：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARQ%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="toc-text">ARQ协议：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">TCP流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text">TCP拥塞控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%8F%AF%E9%9D%A0%E8%BF%90%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE%E5%92%8C%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%EF%BC%89"><span class="toc-text">TCP 可靠运输的实现（连续ARQ协议和超时重传）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8EUDP%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">与UDP的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-HTTP1-0-1-1"><span class="toc-text">2.HTTP1.0 1.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">3.HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-JWT"><span class="toc-text">4.JWT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#localhost%E4%B8%8E127-0-0-1"><span class="toc-text">localhost与127.0.0.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E8%B0%93%E7%9A%84TCP%E7%B2%98%E5%8C%85"><span class="toc-text">所谓的TCP粘包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88HTTP%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%EF%BC%89TCP%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-text">（HTTP环境下的）TCP性能问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E4%BA%8B%E5%8A%A1%E6%97%B6%E5%BB%B6%E5%88%86%E6%9E%90"><span class="toc-text">HTTP事务时延分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%81%9A%E7%84%A6%E7%82%B9"><span class="toc-text">性能聚焦点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%8F%A1%E6%89%8B%E6%97%B6%E5%BB%B6"><span class="toc-text">TCP连接的握手时延</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4"><span class="toc-text">延迟确认</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-text">TCP慢启动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Nagle%E7%AE%97%E6%B3%95%E4%B8%8ETCP-NODELAY"><span class="toc-text">Nagle算法与TCP_NODELAY</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TIME-WAIT%E7%A7%AF%E7%B4%AF%E4%B8%8E%E7%AB%AF%E5%8F%A3%E8%80%97%E5%B0%BD"><span class="toc-text">TIME_WAIT积累与端口耗尽</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF%E6%94%BB%E5%87%BB"><span class="toc-text">CSRF攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS%E6%94%BB%E5%87%BB"><span class="toc-text">XSS攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E6%9C%BA%E5%88%B6"><span class="toc-text">HTTPS机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88MYSQL-amp-Redis%EF%BC%89"><span class="toc-text">数据库（MYSQL &amp; Redis）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-MySQL-%E8%A7%86%E5%9B%BE"><span class="toc-text">1.MySQL- 视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MySQL-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-text">2.MySQL- 存储过程与函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-MySQL-log"><span class="toc-text">3.MySQL log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E7%89%B9%E6%80%A7"><span class="toc-text">InnoDB特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8EMyISAM%E5%AF%B9%E6%AF%94"><span class="toc-text">与MyISAM对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Redis-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">4.Redis 缓存雪崩 缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">缓存穿透</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Redis-%E7%9A%84%E8%BF%91%E4%BC%BC-LRU-%E7%AE%97%E6%B3%95"><span class="toc-text">5.Redis 的近似 LRU 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">Redis 分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%BC%93%E5%AD%98%E4%B8%8EDB%E5%90%8C%E6%AD%A5"><span class="toc-text">Redis 缓存与DB同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%90%E8%A1%8C%E6%96%B9%E6%A1%88%EF%BC%9ACache-Aside-Pattern"><span class="toc-text">基本运行方案：Cache Aside Pattern</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E8%A7%A6%E5%8F%91%E5%99%A8-UDF%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81%EF%BC%89"><span class="toc-text">MySQL触发器 UDF函数（主动推送）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Mysql-binlog-gt-%E4%B8%AD%E9%97%B4%E4%BB%B6-canal-gt-Redis"><span class="toc-text">通过Mysql binlog -&gt; 中间件(canal) -&gt; Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9%E4%B8%8E%E5%A4%8D%E5%88%B6%E4%B8%BB%E4%BB%8E%E8%A1%A8"><span class="toc-text">6.数据库主从节点与复制主从表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">7.聚簇索引和非聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Hash%E7%B4%A2%E5%BC%95%E5%92%8CB-%E6%A0%91%E7%B4%A2%E5%BC%95%E5%AF%B9%E6%AF%94%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="toc-text">8.Hash索引和B+树索引对比以及应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%9C%80%E5%B7%A6%E7%B4%A2%E5%BC%95%E5%8E%9F%E5%88%99"><span class="toc-text">9.最左索引原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Mysql-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-text">10.Mysql 用户权限管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%B0%8F%E8%AE%BE%E8%AE%A1%EF%BC%8C%E7%AE%97%E6%B3%95%E7%AD%89"><span class="toc-text">各种小设计，算法等</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E5%8F%8D%E6%92%A4%E9%94%80%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">撤销反撤销的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%B1%BB%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E9%80%9F%E5%BA%A6"><span class="toc-text">各类算法排序速度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%8E%92%E5%9F%BA%E5%87%86%E5%85%83%E7%B4%A0%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">快排基准元素的选择</span></a></li></ol></li></ol></li></ol>
  </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header"><i class="iconfont icon-wenzhang_huaban" style="padding-right: 2px;"></i>最近文章</div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-03-14</div>
        <a href="/2021/03/14/useful-websites/"><div class="recent-posts-item-content">实用网站与应用分享（一）</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-03-14</div>
        <a href="/2021/03/14/interview-points/"><div class="recent-posts-item-content">Java/后端方向 面试常见知识点整理（未完成）</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-03-05</div>
        <a href="/2021/03/05/hexo-deploy-tarvis/"><div class="recent-posts-item-content">使用 Hexo + Github Pages + Travis 自动部署个人博客</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-02-24</div>
        <a href="/2021/02/24/leetcode-note-raw/"><div class="recent-posts-item-content">LeetCode刷题笔记（归档1）</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
        </div>
      </div>
    </div>
  </div>
  
  <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>Copyright ©
          
          2020 -
          
          2021
        </span>
        <a href="/" class="footer-link">Kibou's blog </a>
      </div>
    </div>

    
    <div class="footer-dsc">
      
      
      Powered by
      <a href="https://hexo.io/" class="footer-link" target="_blank" rel="nofollow noopener noreferrer">&nbsp;Hexo </a>
      
      
      <span>&nbsp;|&nbsp;</span>
      
      
      
      Theme -
      <a href="https://github.com/theme-kaze" class="footer-link" target="_blank"
        rel="nofollow noopener noreferrer">&nbsp;Kaze</a>
      
    </div>
    
    
    
    
      <div class="footer-dsc">
        
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
        
        <span>&nbsp;|&nbsp;</span>
        
        
        本站总访客数<span id="busuanzi_value_site_uv"></span>次
        
      </div>
      
    
</footer>
  <a role="button" id="scrollbutton" class="basebutton" >
  <i class="iconfont icon-arrowleft button-icon"></i>
</a>
<a role="button" id="menubutton" class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a role="button" id="popbutton" class="basebutton">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a role="button" id="darkbutton" class="basebutton darkwidget">
  <i class="iconfont icon-weather button-icon"></i>
</a>

  
  
  
  <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img');
    var i;
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a');
      wrapper.setAttribute('data-fslightbox', 'gallery');
      wrapper.setAttribute('href', img[i].getAttribute('data-src'));
      wrapper.setAttribute('style', 'width: 100%; display: flex; justify-content: center;');
      img[i].parentElement.insertBefore(wrapper, img[i]);
      wrapper.appendChild(img[i]);
    }
    refreshFsLightbox();
  }
</script>
<script>loadScript("//cdn.jsdelivr.net/npm/fslightbox@3.1.0/index.min.js", addImgLayout)</script>
  
  
  
<script src="/js/main.js"></script>

  
  <script>loadScript("/js/lib/busuanzi.min.js")</script>
  
  
  <script>
    var addLazyload = function () {
      var observer = lozad('.lozad', {
        load: function (el) {
          el.srcset = el.getAttribute('data-src');
        },
        loaded: function (el) {
          el.classList.add('loaded');
        }
      });
      observer.observe();
    }
  </script>
  <script>loadScript("/js/lib/lozad.min.js", addLazyload)</script>
  
  
</body>

</html>